.model compact 
.stack 64
.data
defining_username        db " please enter your name:",10,13,9,"$"
get_username             db 16
actual_size_of_username  db ?
the_saved_username       db 16 dup('$'),"$"
get_opponnet_name        db 16
actual_size_opponnet_name db ?
the_saved_opponnet_name  db 16 dup('$'),"$"
opponnet_name            db "opponnet name is:$"
finish_the_main_screen   db " press enter key to continue$"
start_page               db "start$"  
string_chat              db "To start chatting press F1:",10,13,"$"
string_game              db "To start the game press F2:",10,13,"$"
string_exit              db "To end the program press ESC:",10,13,"$"
chat_string              db "start chat$"
game_string              db "start game $"
esca                     db "end program$"
the_score                db " score is: $" 
temp_rec                 db  0
opponnet_score_message   db " score is: $" 
timer_score_screen       db   ?
real_time                db   ?
my_score                 db   30h
opponnet_score           db   30h
temp_transmit            db  0
me 	                     db 'Me:','$'
you                      db 'You:','$'
key                      db ?
rec_value                db      ?
cursor_me_row            db      ?
cursor_me_col            db      ?
cursor_you_row           db      ?
cursor_you_col           db      ?
end_of_backspace_left_me db ?
end_of_backspace_left_you db ?
level_indication         db    0
message_level1           db "for level_1 please enter 1: $"
message_level2           db "for level_2 please enter 2: $"
draw_message             db "draw round$"
send_notification_chat   db "you have sent a chat invitation to: $"
send_notification_game   db "you have sent a game invitation to: $"
receieved_notification_chat db " sent you a chat invitation to accept press F1$"
receieved_notification_game  db " sent you a game invitation to accept press F2$" 
define_level                 db "the selected level is: $" 
upper_nodes_names            db 16 dup('$'),"$"
lower_nodes_names            db 16 dup('$'),"$"
size_upper_name              db  ?
size_lower_name              db  ?
and_gate            dw 0000000000000000b
                    dw 0001110000000000b
                    dw 0001001000000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 1111000100000000b
                    dw 0001000100000000b
                    dw 0001000111111111b  ;16x17
                    dw 0001000100000000b
                    dw 1111000100000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 0001001000000000b
                    dw 0001110000000000b
					dw 0000000000000000b

nand_gate           dw 0000000000000000b
                    dw 0001110000000000b
                    dw 0001001000000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 1111000110000000b
                    dw 0001000101000000b
                    dw 0001000101111111b   ;
                    dw 0001000101000000b
                    dw 1111000110000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 0001000100000000b
                    dw 0001001000000000b
                    dw 0001110000000000b
					dw 0000000000000000b

or_gate             dw 0000000000000000b
                    dw 0111111100000000b
                    dw 0010000010000000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 1111000001000000b
                    dw 0001000001000000b
                    dw 0001000001111111b ;
                    dw 0001000001000000b
                    dw 1111000001000000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 0010000010000000b
                    dw 0111111100000000b
					dw 0000000000000000b

nor_gate            dw 0000000000000000b
                    dw 0111111100000000b
                    dw 0010000010000000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 1111000001100000b
                    dw 0001000001010000b
                    dw 0001000001011111b  ;
                    dw 0001000001010000b
                    dw 1111000001100000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 0001000001000000b
                    dw 0010000010000000b
                    dw 0111111100000000b
					dw 0000000000000000b

xor_gate            dw 0000000000000000b
                    dw 0101111100000000b
                    dw 0010100010000000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 1111010001000000b
                    dw 0001010001000000b
                    dw 0001010001111111b ;
                    dw 0001010001000000b
                    dw 1111010001000000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 0010100010000000b
                    dw 0101111100000000b
					dw 0000000000000000b

xnor_gate           dw 0000000000000000b
                    dw 0101111100000000b
                    dw 0010100010000000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 1111010001100000b
                    dw 0001010001010000b
                    dw 0001010001011111b  ;
                    dw 0001010001010000b
                    dw 1111010001100000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 0001010001000000b
                    dw 0010100010000000b
                    dw 0101111100000000b
					dw 0000000000000000b

not_gate            dw 0000000000000000b
                    dw 0011100000000000b
                    dw 0010010000000000b
                    dw 0010001000000000b
                    dw 0010000100000000b
                    dw 0010000010000000b
                    dw 1110000001100000b
                    dw 0010000001010000b
                    dw 0010000001011111b  ;
                    dw 0010000001010000b
                    dw 0010000001100000b
                    dw 0010000010000000b
                    dw 0010000100000000b
                    dw 0010001000000000b
                    dw 0010010000000000b
                    dw 0011100000000000b
					dw 0000000000000000b

zero_0              dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000111000000b
                    dw 0000001000100000b
                    dw 0000001001100000b
                    dw 0000001010100000b  ;
                    dw 0000001100100000b
                    dw 0000001000100000b
                    dw 0000000111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b

one_1               dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000010000000b
                    dw 0000000110000000b
                    dw 0000000010000000b
                    dw 0000000010000000b  ;
                    dw 0000000010000000b
                    dw 0000000010000000b
                    dw 0000000111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;

two_2               dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001110000000b
                    dw 0000010001000000b
                    dw 0000000001000000b
                    dw 0000000010000000b   ;
                    dw 0000000100000000b
                    dw 0000001000000000b
                    dw 0000011111100000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
three_3             dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001111100000b
                    dw 0000000001000000b
                    dw 0000000010000000b
                    dw 0000000001000000b  ;
                    dw 0000000000100000b
                    dw 0000001000100000b
                    dw 0000000111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
four_4              dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000010000000b
                    dw 0000000110000000b
                    dw 0000001010000000b
                    dw 0000010010000000b  ;
                    dw 0000011111000000b
                    dw 0000000010000000b
                    dw 0000000010000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
five_5              dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001111100000b
                    dw 0000001000000000b
                    dw 0000001111000000b
                    dw 0000000000100000b  ;
                    dw 0000000000100000b
                    dw 0000001000100000b
                    dw 0000000111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
six_6               dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000011000000b
                    dw 0000000100000000b
                    dw 0000001000000000b
                    dw 0000001111000000b  ;
                    dw 0000001000100000b
                    dw 0000001000100000b
                    dw 0000000111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
seven_7             dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001111100000b
                    dw 0000000000100000b
                    dw 0000000001000000b
                    dw 0000000010000000b  ;
                    dw 0000000100000000b
                    dw 0000000100000000b
                    dw 0000000100000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
eight_8             dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000111000000b
                    dw 0000001000100000b
                    dw 0000001000100000b
                    dw 0000000111000000b  ;
                    dw 0000001000100000b
                    dw 0000001000100000b
                    dw 0000000111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b

nine_9              dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000111000000b
                    dw 0000001000100000b
                    dw 0000001000100000b
                    dw 0000000111100000b  ;
                    dw 0000000000100000b
                    dw 0000000001000000b
                    dw 0000000110000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
node                dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0001111111111000b
                    dw 0001111111111000b  ;
                    dw 0001111111111000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
node_last_column    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0001111111111000b  ;
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
letter_a            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001110000000b
                    dw 0000010001000000b
                    dw 0000011111000000b  ;
                    dw 0000010001000000b
                    dw 0000010001000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
letter_b            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011111000000b
                    dw 0000010001000000b
                    dw 0000011110000000b  ;
                    dw 0000010001000000b
                    dw 0000011111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
letter_c            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001110000000b
                    dw 0000010001000000b
                    dw 0000010000000000b  ;
                    dw 0000010001000000b
                    dw 0000001111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
letter_d            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011110000000b
                    dw 0000010001000000b  
                    dw 0000010001000000b;
                    dw 0000010001000000b
                    dw 0000011110000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_e            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011111000000b
                    dw 0000010000000000b
                    dw 0000011111000000b  ;
                    dw 0000010000000000b
                    dw 0000011111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b


letter_f            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011111000000b
                    dw 0000010000000000b  
                    dw 0000011100000000b
                    dw 0000010000000000b
                    dw 0000010000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_g            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001111000000b
                    dw 0000010000000000b  
                    dw 0000010111000000b
                    dw 0000010001000000b
                    dw 0000001111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_h            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010001000000b
                    dw 0000010001000000b
                    dw 0000011111000000b  ;
                    dw 0000010001000000b
                    dw 0000010001000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b

letter_I            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011111000000b
                    dw 0000000100000000b
                    dw 0000000100000000b  ;
                    dw 0000000100000000b
                    dw 0000011111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b

letter_J            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000001000000b
                    dw 0000000001000000b
                    dw 0000010001000000b  ;
                    dw 0000010001000000b
                    dw 0000001110000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b    

letter_K            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010001000000b
                    dw 0000010010000000b
                    dw 0000011100000000b  ;
                    dw 0000010010000000b
                    dw 0000010001000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
				    dw 0000000000000000b 

letter_L            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010000000000b
                    dw 0000010000000000b
                    dw 0000010000000000b  ;
                    dw 0000010000000000b
                    dw 0000011111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b  

letter_M            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011011000000b
                    dw 0000010101000000b
                    dw 0000010101000000b  ;
                    dw 0000010001000000b
                    dw 0000010001000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b 

letter_N            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010011000000b
                    dw 0000011001000000b
                    dw 0000010101000000b  ;
                    dw 0000010011000000b
                    dw 0000010001000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
					dw 0000000000000000b
                               ;
            
letter_o            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001110000000b
                    dw 0000010001000000b  
                    dw 0000010001000000b
                    dw 0000010001000000b
                    dw 0000001110000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                               ;  
letter_p            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011110000000b
                    dw 0000010001000000b  
                    dw 0000011110000000b
                    dw 0000010000000000b
                    dw 0000010000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                               ;
letter_q            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001100000000b
                    dw 0000010010000000b  
                    dw 0000010110000000b
                    dw 0000010010000000b
                    dw 0000001101000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                               ;
letter_r            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011110000000b
                    dw 0000010001000000b  
                    dw 0000011110000000b
                    dw 0000010010000000b
                    dw 0000010001000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    
letter_s            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000001110000000b
                    dw 0000010000000000b  
                    dw 0000001110000000b;
                    dw 0000000001000000b
                    dw 0000011110000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_t            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011111000000b
                    dw 0000000100000000b  
                    dw 0000000100000000b
                    dw 0000000100000000b
                    dw 0000000100000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_u            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010001000000b
                    dw 0000010001000000b  
                    dw 0000010001000000b
                    dw 0000010001000000b
                    dw 0000001110000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_v            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010001000000b
                    dw 0000010001000000b  
                    dw 0000010001000000b
                    dw 0000001010000000b
                    dw 0000000100000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_w            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010001000000b
                    dw 0000010001000000b  
                    dw 0000010101000000b
                    dw 0000010101000000b
                    dw 0000011011000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_x            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010001000000b
                    dw 0000001010000000b  
                    dw 0000000100000000b
                    dw 0000001010000000b
                    dw 0000010001000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_y            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000010001000000b
                    dw 0000010001000000b  
                    dw 0000001010000000b
                    dw 0000000100000000b
                    dw 0000000100000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b

letter_z            dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000011111000000b
                    dw 0000000010000000b  
                    dw 0000000100000000b
                    dw 0000001000000000b
                    dw 0000011111000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b
                    dw 0000000000000000b


columns_width              dw  35    ; width=35 distance between columns form 1:9
nodes_distance_even        dw  6 ; distance between nodes in y_axis form 1:9 is 13 but we need to start drawing before the node so =6 will be fair for even columns
nodes_distance_odd         dw  3 ; distance between nodes in y_axis form 1:9 is 13 but we need to start drawing before the node so =6 will be fair for odd columns
temp                       dw    ?   ;used in determining the row location
even_or_odd_column         db  0
last_column_row            db  0    ;used to check if user want to put gate in last column because its arrangnment is differrent
nodes_distance_last        dw  16   ; distance between nodes in y_axis in last column
gate_number                db   ?   ;to know which gate the user want
first_column_leg           dw   ?   ;first digit
first_row_leg              dw   ?   ;second digit
second_column_leg          dw   ?   ;third digit
second_row_leg             dw   ?   ;fourth digit
output_column              dw   ?   ;fifth digit
output_row                 dw   ?   ;sixth digit
arr_col0                   db   5,5,5,5,5,5,5,5,5,5,'$'         ;randomize inputs at first column
arr_col1                   db   5,5,5,5,5,5,5,5,5                    ;nodes column_1
arr_col2                   db   5,5,5,5,5,5,5,5,5                    ;nodes column_2
arr_col3                   db   5,5,5,5,5,5,5,5,5                   ;nodes column_3
arr_col4                   db   5,5,5,5,5,5,5,5,5                    ;nodes column_4
arr_col5                   db   5,5,5,5,5,5,5,5,5                    ;nodes column_5
arr_col6                   db   5,5,5,5,5,5,5,5,5                   ;nodes column_6
arr_col7                   db   5,5,5,5,5,5,5,5,5                    ;nodes column_7
arr_col8                   db   5,5,5,5,5,5,5,5,5                   ;nodes column_8
arr_col9                   db   5,5,5,5,5,5,5,5,5,5                  ;nodes column_9
temp_gates                 db   ?                      ;temporary variable for the operations
temp_find_?_columns        dw   1        ;to determine which column it found the ones or zero or undefined nodes
temp_wire_rows             dw   ?        ;used to know the maximum length of wire in vertical direction
even_or_odd_column_input   dw   0        ;used as indication for odd columns=1 even =0
first_column_row           dw   0        ;used as indication for first column
temp_wire_horizontal_1     dw   ?        ; used to know the maximum length of first horizontal line of the wire
temp_wire_horizontal_2     dw   ?        ; used to know the maximum length of second horizontal line of the wire
remove_first_column_leg    dw   ?
remove_first_row_leg       dw   ?
remove_second_column_leg   dw   ?
remove_second_row_leg      dw   ?
remove_output_column       dw   ?
remove_output_row          dw   ?
saved_col1                 db   99 dup("$")
saved_col2                 db   99 dup("$")
saved_col3                 db   99 dup("$")
saved_col4                 db   99 dup("$")
saved_col5                 db   99 dup("$")
saved_col6                 db   99 dup("$")
saved_col7                 db   99 dup("$")
saved_col8                 db   99 dup("$")
saved_col9                 db   99 dup("$")
overwrite_column           dw     ?
overwrite_row              dw     ?
win                        db    "opponnet win$"
ones_of_my_nodes           db     0
ones_of_opponnet_nodes     db     0
zeros_of_my_nodes          db     0
zeros_of_opponnet_nodes    db     0
i_win                      db     " won$"
counter1                     dw   0
counter2                     dw   0
counter3                     dw   0
counter4                     dw   0
counter5                     dw   0
counter6                     dw   0
counter7                     dw   0
counter8                     dw   0
counter9                     dw   0
timer                        db   ?
error_message                db   "ERROR COMMAND PLEASE TRY AGAIN$"
i_won                        db    ?
opponnet_won                 db    ? 
my_command                   db    8 dup("$"),'$'
opponnet_command             db    8 dup("$"),'$'
counter_my_command           db    0
counter_opponnet_command     db    0    
.code
clearing_buffer proc              ;just to clear buffer  neither take anything nor return something
;clearing buffer (if user press any other key i will clear buffer to wait for the required key)
    mov ah,0ch
    mov al,0
    int 21h
    ret
clearing_buffer endp

display_string proc 
    mov ah,9h
    mov dx,bx ;Display string 
    int 21h
    ret
display_string endp

get_string proc 
    mov ah,0AH        
    mov dx,bx                 
    int 21h
    ret
get_string endp

display_char proc ;display_char in al
mov ah,2
mov dl,al
int 21h
ret
display_char endp
moving_cursor proc
    mov ah,3h         ;Get Cursor position (Saved in DL,DH)
    mov bh,0h
    int 10h
      
    mov ah,2          ;Move Cursor
    mov dl,0
    add dh,5h      ;X,Y Position
    int 10h           ;BIOS INT

    ret
moving_cursor endp

intialize_com1 proc
; initinalize COM
    ;Set Divisor Latch Access Bit
    mov dx,3fbh 			; Line Control Register
    mov al,10000000b		;Set Divisor Latch Access Bit
    out dx,al				;Out it
    ;Set LSB byte of the Baud Rate Divisor Latch register.
    mov dx,3f8h			
    mov al,0ch			
    out dx,al

    ;Set MSB byte of the Baud Rate Divisor Latch register.
    mov dx,3f9h
    mov al,00h
    out dx,al

    ;Set port configuration
    mov dx,3fbh
    mov al,00011011b
    out dx,al

ret
intialize_com1 endp

transmit_name proc
    mov cl,actual_size_of_username
    inc cl
    inc cl
    mov ch,0
    mov bx,0
    ;Check that Transmitter Holding Register is Empty
   repeat_transmit:         mov dx , 3FDH		; Line Status Register
    AGAIN_trans:  
            In al , dx 			;Read Line Status
            AND al ,00100000b
            JZ AGAIN_trans

    ;If empty put the VALUE in Transmit data register
            mov dx ,3F8H		; Transmit data register
            mov al,the_saved_username[bx]
            out dx,al
            inc bx
           ; inc temp_transmit
            dec cx
            jnz repeat_transmit
ret
transmit_name endp

recieve_name proc
;set cursor
    mov ah,2          ;Move Cursor
    mov dx,0400h
    mov bh,0
    int 10h           ;BIOS INT

    mov ah,9
    mov dx,offset opponnet_name
    int 21h

mov bx,0
;Check that Data Ready
   repeat_rec:         mov dx , 3FDH		; Line Status Register
    CHK:	in al , dx 
            AND al ,1
            JZ CHK

    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al , dx 
            mov the_saved_opponnet_name[bx], al
            cmp the_saved_opponnet_name[bx],'$'
			jz exit_label
    
    mov ah,2
    mov dl,the_saved_opponnet_name[bx]
    int 21h
    ;dec cx
    ;jnz repeat_recs
    mov actual_size_opponnet_name,bl
    inc bx
    jmp repeat_rec 

exit_label:
      

ret
recieve_name endp
defining_screen proc far
label_defining_screen:
;clearing screen
    mov ax,0600h      ;Scroll Screen AH=06 (Scroll),AL=0 Entire Page
    mov bh,07         ;Normal attributes
    mov cx,0          ;from 0,0
    mov dx,184FH      ;To 18h,4fh  80*25
    int 10h           ;Clear Screen
    
    ;set cursor
    mov ah,2          ;Move Cursor
    mov dx,0000h
    mov bh,0
    int 10h           ;BIOS INT

    ;main screen
    lea bx,defining_username    
    call display_string

label_get_username:
    lea bx,get_username  
    call get_string
    cmp the_saved_username[0],60h     ;ascii code for a
    jna label_defining_screen
    cmp the_saved_username[0],7ah     ;ascii code for z
    ja label_defining_screen




go_transmit:
    call intialize_com1
            mov dx , 3FDH		; Line Status Register  
            In al , dx 			;Read Line Status
            AND al ,00000001b
            JZ fisrt_sender
            call transmit_name
            mov dx ,03F8H
            in al ,dx 
            call recieve_name
            jmp transmit_completed

fisrt_sender:
    mov dx ,3F8H		; Transmit data register
    out dx,al
    call recieve_name
    call transmit_name



    


   transmit_completed:

     call moving_cursor 

    
     
    lea bx,finish_the_main_screen 
    call display_string

    ;waiting for enter key 
   check_for_enter_key:
    mov ah,0
    int 16h   ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
   ; jz check_for_enter_key 

    ;scan code for enter key
    cmp ah,1ch
    jz continue1 
    
    ;clearing buffer to check the enter key(if user press any other key i will clear buffer to wait for enter key)
   call clearing_buffer
    jmp check_for_enter_key


continue1:
; ;clearing screen
;     mov ax,0600h      ;Scroll Screen AH=06 (Scroll),AL=0 Entire Page
;     mov bh,07         ;Normal attributes
;     mov cx,0          ;from 0,0
;     mov dx,184FH      ;To 18h,4fh  80*25
;     int 10h           ;Clear Screen
    
;     ;set cursor
;     mov ah,2          ;Move Cursor
;     mov dx,0000h
;     mov bh,0
;     int 10h           ;BIOS INT

;     mov bx,0
; get_size:
;     mov al,the_saved_opponnet_name[bx]
;     cmp al,'$'
;     jnz get_size
;     mov actual_size_opponnet_name,bl


    ; add actual_size_opponnet_name,30h
    ; mov ah,2
    ; mov dl,actual_size_opponnet_name
    ; int 21h


   
;    mov bx,0
; kml_asm:
;    cmp the_saved_opponnet_name[bx],"$"
;    jz  stop 
;     mov ah,2
;    mov dl,the_saved_opponnet_name[bx]
;    int 21h
;    inc bx
;    jmp kml_asm
   
; stop:
; mov ah,9
; mov dx,offset the_saved_opponnet_name
; int 21h

; mov ah,0
; int 16h



ret
defining_screen endp

reset_data_variables proc ;return the intial values of the variables 
    mov cx,82d     ;3dd l loops
    mov bx,0       ;
reset_values_nodes:
    mov arr_col1[bx],5    
    inc bx  
    loop reset_values_nodes

     mov cx,891d
     mov bx,0
  reset_the_saved_inputs:
     mov saved_col1[bx],"$"
     inc bx 
     loop reset_the_saved_inputs

     mov ones_of_my_nodes,0                  ;to reset the winner indications
     mov ones_of_opponnet_nodes,0
     mov zeros_of_my_nodes,0              
     mov zeros_of_opponnet_nodes,0

     mov counter1,0                ;to reset all counetrs  
     mov counter2,0
     mov counter3,0
     mov counter4,0
     mov counter5,0
     mov counter6,0
     mov counter7,0
     mov counter8,0
     mov counter9,0
ret
reset_data_variables endp

Get_ScreenPos	proc		;takes X in cx, Y in dx, returns DI pointing to memory pos of X,Y
	push ax
	push bx
	push cx
	push dx

	xor ax,ax		;setting to zero

	mov ax,320d	;Y*ScreenWidth + X
	mul dx
	add ax,cx

	mov di,ax

	pop dx
	pop cx
	pop bx
	pop ax

	ret
Get_ScreenPos	endp

 Draw_anything proc    ;takes X in cx, Y in dx, Si pointing to an array, Al =color , Ah = back ground color

	push ax
	push bx
	push cx
	push dx
    push di

	call Get_ScreenPos            ;get position in di

	mov dl,al                    ;dl= colour
	mov cx,17

	Drawing_Row1:
	    lodsw    			    ;take first row in ax

	    xchg ax,dx		    	    ;put color in al, and first row of bitmap in dl   dx=word   al=colour

	    mov bx,1000000000000000b	    ;for checking if the first bit is one
	    Drawing_Pixels1:
		test dx,bx
		jz BackGND1

		stosb		    	    ;put color in di from al  ;lazm y3dy 3la da 34an yrsm
		jmp Next_Pixel1

		BackGND1:


		inc di

		Next_Pixel1:
		shr bx,1
	    jnz Drawing_Pixels1

	    add di, 320 - 16
	    xchg ax,dx		    	    ;put color in dl to get it back next loop
	loop Drawing_Row1

    pop di
	pop dx
	pop cx
	pop bx
	pop ax

	ret
Draw_anything	endp

draw_numbers proc
;draw numbers
;odd column numbering
    mov cx,38
    mov dx,13
    mov si,offset one_1
    mov al,00
numbering1:
    call Draw_anything
    add dx,16
    cmp dx,157
    jnz numbering1
    add cx,70
    cmp cx,318
    mov dx,13
    mov si,offset one_1
    jnz numbering1

;even column numbering
    mov cx,73
    mov dx,19
    mov si,offset one_1
    mov al,00
even_numbering1:
    call Draw_anything
    add dx,16
    cmp dx,163
    jnz even_numbering1
    add cx,70
    cmp cx,353
    mov dx,19
    mov si,offset one_1
    jnz even_numbering1

;first and last column numbering
    mov cx,5
    mov dx,9
    mov si,offset zero_0
    mov al,00
first_last_numbering1:
    call Draw_anything
    add dx,16
    cmp dx,169
    jnz first_last_numbering1
    add cx,295
    cmp cx,595
    mov dx,9
    mov si,offset zero_0
    jnz first_last_numbering1

;column(mn t7t)_numbering
    mov cx,0
    mov dx,165
    mov si,offset zero_0

    mov al,00
    call Draw_anything
    add cx,30d
  draw_column_numbers:
    mov al,00
    call Draw_anything
    add cx,35
    cmp cx,310
    jnz draw_column_numbers
    mov cx,308
    mov al,0
    mov si,offset nine_9
    call Draw_anything

ret
draw_numbers endp

the_8_vertical_lines proc
;make the 8 vertical lines
  mov dx,15d
  mov cx,37d
  lines_vertical:  int 10h
  inc dx
  cmp dx,165
  jnz lines_vertical
  add cx,35d
  mov dx,15d
  cmp cx,317d
  jnz lines_vertical

ret
the_8_vertical_lines endp

first_second_horizontal proc
;make the first horizontal line
    mov cx,5d         ;Column
    mov dx,15d       ;Row
    mov bh,0h
    mov al,00h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
  line_horizontal1:  int 10h
  inc cx                                          ;total distance for the game 160 row,
  cmp cx,315
  jnz line_horizontal1


  ;make the second horizontal line
  mov dx,165d
  mov cx,5d
  line_horizontal2:  int 10h
  inc cx
  cmp cx,315
  jnz line_horizontal2
ret
first_second_horizontal endp

draw_game proc far

     ;white screen   bsbt kol column w bm4y 3la kol l rows 34an abyd l 4a4a
    mov cx,0d          ;Column
    mov dx,0d          ;Row
    mov bh,0h
    mov al,0fh         ;Pixel color
    mov ah,0ch         ;Draw Pixel Command
  vertical:  int 10h
  inc dx
  cmp dx,180d
  jnz vertical
  inc cx
  cmp cx,320
  mov dx,0
  jnz vertical


  
call first_second_horizontal


   ;make the third horizontal line
  mov dx,180d
  mov cx,5d
  line_horizontal3:  int 10h
  inc cx
  cmp cx,315
  jnz line_horizontal3

  call the_8_vertical_lines

 ;nodes coulumn 1,3,5,7
    mov si,22d
    mov cx,32d          ;Column
    mov di,cx
    add di,10d
    rect: mov dx,si         ;Row
    add si,3d
  rect_cont:  int 10h
    inc cx
    cmp cx,di
    jnz rect_cont
    sub cx,10d
    inc dx
    cmp dx,si
    jnz rect_cont
    add si,13d
    cmp si,166d
    jnz rect
    add cx,70d
    add di,70d
    mov si,22d
    cmp cx,312d
    jnz rect


    ;nodes coulumn ,2,4,6,8
    mov si,28d
    mov cx,67d          ;Column
    mov di,cx
    add di,10d
    rect1: mov dx,si         ;Row
    add si,3d
  rect_cont1:  int 10h
    inc cx
    cmp cx,di
    jnz rect_cont1
    sub cx,10d
    inc dx
    cmp dx,si
    jnz rect_cont1
    add si,13d
    cmp si,172d
    jnz rect1
    add cx,70d
    add di,70d
    mov si,28d
    cmp cx,347d
    jnz rect1






;my nodes last column
    mov cx,319d         ;Column
    mov dx,18d       ;Row
    mov bh,0h
    mov al,07h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
    first_node2: int 10h
    dec cx
    cmp cx,310
    jnz first_node2
    mov si,319d
    mov dx,31d       ;Row
    my_nodes: mov cx,si         ;Column
   my_nodes2: int 10h
    dec cx
    cmp cx,310d
    jnz my_nodes2
    add dx,16d
    cmp dx,95d
    jnz my_nodes

    ;opponnet nodes
    mov si,319d
    mov dx,95d       ;Row
    mov bh,0h
    mov al,09h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
    oppo_nodes: mov cx,si         ;Column
   oppo_nodes2: int 10h
    dec cx
    cmp cx,310
    jnz oppo_nodes2
    add dx,16
    cmp dx,175
    jnz oppo_nodes

    call draw_numbers

    ret
    draw_game endp



   

output_position proc     ;get output position in cx for column and dx for row and take output_column ,output_row
    ;for rows
    ;get column number

    ;clearing buffer (if user press any other key i will clear buffer to wait for the required key)
    call clearing_buffer
    mov ax,output_column
    cmp al,9
    jnz not_last_column
    mov last_column_row,1      ;indication for last column
not_last_column:
    ror al,1
    jc odd_column
    jmp even_column
    odd_column:
    mov even_or_odd_column,1     ;indication for odd column =1  , even column =0

;equation  35(x-1)+37-21
even_column:

     ;determine the position of output column in cx for even columns or odd columns or last column
    rol al,1
    sub al,1h                 ;sub 1 to exclude first column
    mov ah,0
    mul columns_width          ;width=35 distance between columns form 1:9
    add ax,37
    mov cx,ax
    sub cx,21d                ;to start drawing in the space between two coulumns


    ;for rows
    cmp last_column_row,1
    jz last_column
    cmp even_or_odd_column,1
    jz rows_for_odd_columns
    ;if columns even
    ;get row number
    ;clearing buffer (if user press any other key i will clear buffer to wait for the required key)
    call clearing_buffer

    ; equation 6x+15+10(x-1)
    mov ah,0
    mov ax,output_row
    mov temp,ax
    dec temp  ;temp=x-1
    mul nodes_distance_even     ; distance between nodes in y_axis form 1:9 is 13 but we need to start drawing before the node so =6 will be fair
    add ax,15d
    mov dx,ax
    mov ax,10d
    mov bx,dx
    mul temp
    mov dx,bx
    add dx,ax                 ;to centrize the gate
    jmp continue_which_gate


    rows_for_odd_columns:
    ;if columns odd
     ;get row number
    ;clearing buffer (if user press any other key i will clear buffer to wait for the required key)
   call clearing_buffer

    ;equation 3x+12+13(x-1)
    mov ah,0
    mov ax,output_row
    mov temp,ax
    dec temp      ;temp=x-1
    mul nodes_distance_odd         ; distance between nodes in y_axis form 1:9 is 13 but we need to start drawing before the node so =3 will be fair
    add ax,12d
    mov dx,ax
    mov ax,13d
    mov bx,dx
    mul temp
    mov dx,bx
    add dx,ax                 ;to centrize the gate
    mov even_or_odd_column,0
    jmp continue_which_gate

    ;if column 9 last column
    last_column:
     ;get row number
    ;clearing buffer (if user press any other key i will clear buffer to wait for the required key)
    call clearing_buffer
    mov ah,0
    mov ax,output_row
    ;if first row
    cmp al,0
    jnz not_the_first_node
    mov dx,10d                ;
    jmp first_node_last_col
    ;the rest of rows
    ;equation  16(x-1)+23
  not_the_first_node:
    dec ax
    mul nodes_distance_last        ; distance between nodes in y_axis in last column  =16
    add ax,23d
    mov dx,ax
 first_node_last_col:

    mov last_column_row,0              ;setting to zero to continue playing
    mov even_or_odd_column,0           ;setting to zero because the column 9 is odd
    jmp continue_which_gate

    continue_which_gate:

    ret
output_position endp

draw_and proc           ;takes X in cx, Y in dx, Si pointing to its array, Al = color , Ah = back ground color
    mov si,offset and_gate
    mov al,01                       ;colur blue
    call Draw_anything                ;
ret
draw_and endp

draw_or proc                        ;takes X in cx, Y in dx, Si pointing to bitmap of variable, Al = sprite color , Ah = back ground color
    mov si,offset or_gate
    mov al,01
    call Draw_anything
ret
draw_or endp

draw_nand proc                        ;takes X in cx, Y in dx, Si pointing to bitmap of variable, Al = sprite color , Ah = back ground color
    mov si,offset nand_gate
    mov al,01
    call Draw_anything
ret
draw_nand endp

draw_nor proc                        ;takes X in cx, Y in dx, Si pointing to bitmap of variable, Al = sprite color , Ah = back ground color
    mov si,offset nor_gate
    mov al,01
    call Draw_anything
ret
draw_nor endp

draw_xor proc                        ;takes X in cx, Y in dx, Si pointing to bitmap of variable, Al = sprite color , Ah = back ground color
    mov si,offset xor_gate
    mov al,01
    call Draw_anything
ret
draw_xor endp

draw_xnor proc                        ;takes X in cx, Y in dx, Si pointing to bitmap of variable, Al = sprite color , Ah = back ground color
    mov si,offset xnor_gate
    mov al,01
    call Draw_anything
ret
draw_xnor endp

draw_not proc                        ;takes X in cx, Y in dx, Si pointing to bitmap of variable, Al = sprite color , Ah = back ground color
    mov si,offset not_gate
    mov al,01
    call Draw_anything
ret
draw_not endp

input_position_upper_leg proc   ;get input position for upper leg in cx for column and dx for row and take first column leg and first row leg
    ;get column number

    ;clearing buffer (if user press any other key i will clear buffer to wait for the required key)
    call clearing_buffer
    mov ax,first_column_leg
    cmp al,0
    jnz not_first_column
    mov first_column_row,1      ;indication for first column
not_first_column:
    ror al,1
    jc odd_column_input
    jmp even_column_input
    odd_column_input:
    mov even_or_odd_column_input,1     ;indication for odd column =1  , even column =0
even_column_input:

     ;determine the position of input column in cx for even columns or odd columns or first column
    rol al,1
    cmp first_column_leg,0        ;because the first column does not match the sequence of column from 1 to 8
    jnz other_columns
    mov cx,10
    mov temp_wire_horizontal_1,cx
    mov temp_wire_horizontal_2,cx
    add temp_wire_horizontal_1,2
    add temp_wire_horizontal_2,5
    jmp go_for_rows

    other_columns:
;if any other column equation   35(x-1)+42
    sub al,1h
    mov ah,0
    mov bx,35d
    mul bx          ;width=35 distance between columns form 1:8
    add ax,42
    mov cx,ax
    mov temp_wire_horizontal_1,cx
    mov temp_wire_horizontal_2,cx
    add temp_wire_horizontal_1,2                  ;to get the maximum lenght of the first horizontal line
    add temp_wire_horizontal_2,8                  ;to get the maximum lenght of the second horizontal line


go_for_rows:
    ;for rows
    cmp first_column_row,1
    jz jump_help
    cmp even_or_odd_column_input,1
    jz rows_for_odd_columns_input


    ;if columns even
    ;get row number
;column 8 must be in special case because the nodes in column 9 is not as any nodes
    cmp first_column_leg,8
    jnz other_evens
  ;equation= 16(x-1)+28                   x=first_row_leg
    mov dx,first_row_leg          ;Row           ;22  to determine the position of the row
    mov ax,16d
    dec dx
    mul dx
    add ax,28d
    mov dx,ax

    mov even_or_odd_column_input,0
    jmp draw_upper_wire

    other_evens:
     ;equation= 16(x-1)+28                   x=first_row_leg
    mov dx,first_row_leg          ;Row           ;22  to determine the position of the row
    mov ax,16d
    dec dx
    mul dx
    add ax,28d
    mov dx,ax
    mov even_or_odd_column_input,0
    jmp draw_upper_wire

jump_help: jmp first_column
    rows_for_odd_columns_input:

    
    ;if columns odd
     ;get row number
;equation= 16(x-1)+22
    mov dx,first_row_leg          ;Row           ;22  to determine the position of the row
    mov ax,16d
    dec dx
    mul dx
    add ax,22d
    mov dx,ax
    mov even_or_odd_column_input,0
    jmp draw_upper_wire

    ;if column 0 first column
    first_column:


     ;get row number
    mov ah,0
    mov ax,first_row_leg
    ;if first row
    cmp al,0
    jnz not_the_first_node_input
    mov dx,18                ;
    jmp first_node_first_col
    ;the rest of rows
    ;equation  16(x-1)+31
  not_the_first_node_input:
    dec ax
    mov bx,16d
    mul bx                        ; distance between nodes in y_axis in first column  =16
    add ax,31d
    mov dx,ax

 first_node_first_col:

    mov first_column_row,0              ;setting to zero to continue playing
    mov even_or_odd_column_input,0
    jmp draw_upper_wire

    draw_upper_wire:

    ret
input_position_upper_leg endp

draw_wire_command proc
     wire_down_command:

    call output_position
    mov ax,dx        ;nhaya
    add ax,7d
    push ax
    call input_position_upper_leg
    mov bx,dx        ;bdaya
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jz wire_1_diff
    pop ax
    wire_2_diff:
    add temp_wire_horizontal_1,5
    add temp_wire_horizontal_2,51
    jmp check_up_or_down
wire_1_diff:
    pop ax
    add temp_wire_horizontal_1,5
    add temp_wire_horizontal_2,16

check_up_or_down:
    mov temp_wire_rows,ax
    add temp_wire_rows,1
    cmp bx,ax
    ja wire_up_command
    mov bh,0h
    mov al,01h          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire_command:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire_command
vertical_wire_command:
    inc dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire_command

    horizontal2_wire_command:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire_command

    jmp done_wiring_command
    wire_up_command:
    mov bh,0h
    mov al,01h          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire1_command:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire1_command
vertical_wire1_command:
    dec dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire1_command

    horizontal2_wire1_command:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire1_command

    done_wiring_command:





ret
draw_wire_command endp



remove_wire_command proc
    rem_wire_down_command:

    call output_position
    mov ax,dx        ;nhaya
    add ax,7d
    push ax
    call input_position_upper_leg
    mov bx,dx        ;bdaya
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jz remove_wire_1_diff
    pop ax
    remove_wire_2_diff:
    add temp_wire_horizontal_1,5
    add temp_wire_horizontal_2,51
    jmp remove_check_up_or_down
remove_wire_1_diff:
    pop ax
    add temp_wire_horizontal_1,5
    add temp_wire_horizontal_2,16

remove_check_up_or_down:
    mov temp_wire_rows,ax
    add temp_wire_rows,1
    cmp bx,ax
    ja remove_wire_up_command
    mov bh,0h
    mov al,0fh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    rem_horizontal_wire_command:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz rem_horizontal_wire_command
rem_vertical_wire_command:
    inc dx
    cmp dx,temp_wire_rows
    int 10h
    jnz rem_vertical_wire_command

    rem_horizontal2_wire_command:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz rem_horizontal2_wire_command

    jmp rem_done_wiring_command
    remove_wire_up_command:
    mov bh,0h
    mov al,0fh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    rem_horizontal_wire1_command:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz rem_horizontal_wire1_command
rem_vertical_wire1_command:
    dec dx
    cmp dx,temp_wire_rows
    int 10h
    jnz rem_vertical_wire1_command

    rem_horizontal2_wire1_command:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz rem_horizontal2_wire1_command

    rem_done_wiring_command:





ret
remove_wire_command endp

upper_wire_for_gates proc

wire_down:

    call output_position
    mov ax,dx        ;nhaya
    add ax,6d
    push ax
    call input_position_upper_leg
    mov bx,dx        ;bdaya
    pop ax
    mov temp_wire_rows,ax
    cmp bx,ax
    ja wire_up
    mov bh,0h
    mov al,06h          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire
vertical_wire:
    inc dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire

    horizontal2_wire:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire

    jmp done_wiring
    wire_up:
    mov bh,0h
    mov al,06h          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire1:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire1
vertical_wire1:
    dec dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire1

    horizontal2_wire1:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire1

    done_wiring:

ret
upper_wire_for_gates endp

input_position_lower_leg proc   ;get input position for upper leg in cx for column and dx for row and take
    ;get column number

    ;clearing buffer (if user press any other key i will clear buffer to wait for the required key)
    call clearing_buffer
    mov ax,second_column_leg
    cmp al,0
    jnz not_first_column1
    mov first_column_row,1      ;indication for first column
not_first_column1:
    ror al,1
    jc odd_column_input1
    jmp even_column_input1
    odd_column_input1:
    mov even_or_odd_column_input,1     ;indication for odd column =1  , even column =0
even_column_input1:

     ;determine the position of input column in cx for even columns or odd columns or first column
    rol al,1
    cmp second_column_leg,0        ;because the first column does not match the sequence of column from 1 to 8
    jnz other_columns1
    mov cx,10
    mov temp_wire_horizontal_1,cx
    mov temp_wire_horizontal_2,cx
    add temp_wire_horizontal_1,4
    add temp_wire_horizontal_2,5
    jmp go_for_rows1

    other_columns1:
;if any other column equation   35(x-1)+42
    sub al,1h
    mov ah,0
    mov bx,35d
    mul bx          ;width=35 distance between columns form 1:8
    add ax,42
    mov cx,ax
    mov temp_wire_horizontal_1,cx
    mov temp_wire_horizontal_2,cx
    add temp_wire_horizontal_1,4                  ;to get the maximum lenght of the first horizontal line
    add temp_wire_horizontal_2,8                  ;to get the maximum lenght of the second horizontal line


go_for_rows1:
    ;for rows
    cmp first_column_row,1
    jz jump_help1
    cmp even_or_odd_column_input,1
    jz rows_for_odd_columns_input1
    ;if columns even
    ;get row number

;column 8 must be in special case because the nodes in column 9 is not as any nodes
    cmp second_column_leg,8
    jnz other_evens1
  ;equation= 16(x-1)+28                   x=first_row_leg
    mov dx,second_row_leg          ;Row           ;22  to determine the position of the row
    mov ax,16d
    dec dx
    mul dx
    add ax,28d
    mov dx,ax

    mov even_or_odd_column_input,0
    jmp draw_upper_wire1

    other_evens1:
     ;equation= 16(x-1)+28                   x=first_row_leg
    mov dx,second_row_leg          ;Row           ;22  to determine the position of the row
    mov ax,16d
    dec dx
    mul dx
    add ax,28d
    mov dx,ax
    mov even_or_odd_column_input,0
    jmp draw_upper_wire1

jump_help1: jmp first_column1
    rows_for_odd_columns_input1:
    ;if columns odd
     ;get row number

;equation= 16(x-1)+22
    mov dx,second_row_leg          ;Row           ;22  to determine the position of the row
    mov ax,16d
    dec dx
    mul dx
    add ax,22d
    mov dx,ax
    mov even_or_odd_column_input,0
    jmp draw_upper_wire1

    ;if column 0 first column
    first_column1:


     ;get row number
    mov ah,0
    mov ax,second_row_leg
    ;if first row
    cmp al,0
    jnz not_the_first_node_input1
    mov dx,18                ;
    jmp first_node_first_col1
    ;the rest of rows
    ;equation  16(x-1)+31
  not_the_first_node_input1:
    dec ax
    mov bx,16d
    mul bx                        ; distance between nodes in y_axis in first column  =16
    add ax,31d
    mov dx,ax

 first_node_first_col1:

    mov first_column_row,0              ;setting to zero to continue playing
    mov even_or_odd_column_input,0
    jmp draw_upper_wire1

    draw_upper_wire1:

    ret
input_position_lower_leg endp

lower_wire_for_gates proc

wire_down1:

    call output_position
    mov ax,dx        ;nhaya
    add ax,10d
    push ax
    call input_position_lower_leg  ;
    mov bx,dx        ;bdaya
    pop ax
    mov temp_wire_rows,ax
    cmp bx,ax
    ja wire_up1
    mov bh,0h
    mov al,0dh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire2:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire2
vertical_wire2:
    inc dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire2

    horizontal2_wire2:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire2

    jmp done_wiring1
    wire_up1:
    mov bh,0h
    mov al,0dh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire3:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire3
vertical_wire3:
    dec dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire3

    horizontal2_wire3:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire3

    done_wiring1:

ret
lower_wire_for_gates endp

which_gate_to_draw proc                  ;draw the gates in output position and take gate number
    cmp gate_number,1eh    ;letter a for and has scancode 1eh   (not ascii because the lower case has a different ascii compared to upper case)
    jnz check_or
    call draw_and
    call upper_wire_for_gates
    call lower_wire_for_gates
    jmp continue_playing
check_or:
    cmp gate_number,18h                 ;letter o for or has scancode 18h
    jnz check_nand
    call draw_or
    call upper_wire_for_gates
    call lower_wire_for_gates
    jmp continue_playing
check_nand:
    cmp gate_number,20h    ;letter d for nand has scancode 20h
    jnz check_nor
    call draw_nand
    call upper_wire_for_gates
    call lower_wire_for_gates
    jmp continue_playing
check_nor:
    cmp gate_number,13h    ;letter r for nor has scancode 13h
    jnz check_xor
    call draw_nor
    call upper_wire_for_gates
    call lower_wire_for_gates
    jmp continue_playing
check_xor:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor
    call draw_xor
    call upper_wire_for_gates
    call lower_wire_for_gates
    jmp continue_playing
check_xnor:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not
    call draw_xnor
    call upper_wire_for_gates
    call lower_wire_for_gates
    jmp continue_playing
check_not:
    cmp gate_number,14h    ;letter t for not has scancode 14h
    jnz  check_wire
    call draw_not
    call upper_wire_for_gates
    jmp continue_playing

    check_wire:
    cmp gate_number,11h     
    jnz continue_playing
    call draw_wire_command
    jmp continue_playing


    continue_playing:
ret
which_gate_to_draw endp

whitening_message proc
;white l mkan l messages
    mov cx,0d         ;Column
    mov dx,0d       ;Row
    mov bh,0h
    mov al,0fh         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
  vertical_message:  int 10h
  inc dx
  cmp dx,11d
  jnz vertical_message
  inc cx
  cmp cx,320
  mov dx,0
  jnz vertical_message
ret
whitening_message endp

blacking_message_p1 proc
;white l mkan l messages
    mov ch,0
    mov cl,actual_size_of_username        ;Column
    mov al,8
    mul cl
    mov cx,ax
    add cx,4
    mov dx,183d       ;Row
    mov bh,0h
    mov al,00h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
  in_line_clear:  int 10h
  inc dx
  cmp dx,192d
  jnz in_line_clear
  inc cx
  cmp cx,320
  mov dx,183d
  jnz in_line_clear
ret
blacking_message_p1 endp

blacking_message_p2 proc
;white l mkan l messages
    mov ch,0
    mov cl,actual_size_opponnet_name        ;Column
    mov al,8
    mul cl
    mov cx,ax
    add cx,4
    mov dx,192d       ;Row
    mov bh,0h
    mov al,00h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
  in_line_clear_p2:  int 10h
  inc dx
  cmp dx,200d
  jnz in_line_clear_p2
  inc cx
  cmp cx,320
  mov dx,192d
  jnz in_line_clear_p2
ret
blacking_message_p2 endp

get_first_letter proc                    ;it put first letter in its variabe in the data  and dont return something
first_letter:
    mov ah,2
    mov bh,0
    mov dx,0
    int 10h
    ;waiting for letter a key
   check_for_a_gate:
    mov ah,0
    int 16h                            ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    cmp ah,3eh
    jnz not_f4 
    jmp label_score_screen
not_f4:
    ;jz check_for_a_gate
    ;mov gate_number,ah                 ;save the gate entered in this variable
    mov my_command[0],ah

    push ax
    call whitening_message
    pop ax
    mov ah,2
    mov dl,al
    int 21h

    call clearing_buffer
ret
get_first_letter endp

get_first_column_leg  proc             ;it put first digit in its variabe in the data  and dont return something
;waiting for first digit key
   check_for_first_digit:
    mov ah,0
    int 16h                        ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    cmp ah,3eh
    jnz not1_f4 
    jmp label_score_screen
not1_f4:
    ;jz check_for_first_digit
    sub al,30h
    mov ah,0
    ;mov first_column_leg,ax
    mov my_command[1],al
    mov ah,2
    add al,30h
    mov dl,al
    int 21h

    call clearing_buffer
ret
get_first_column_leg endp

get_first_row_leg  proc               ;it put second digit in its variabe in the data  and dont return something
;waiting for second digit key
   check_for_second_digit:
    mov ah,0
    int 16h                        ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    cmp ah,3eh
    jnz not2_f4 
    jmp label_score_screen
not2_f4:
    ;jz check_for_second_digit
    sub al,30h
    mov ah,0
    ;mov first_row_leg,ax
    mov my_command[2],al
    mov ah,2
    add al,30h
    mov dl,al
    int 21h

    call clearing_buffer
ret
get_first_row_leg endp

get_second_column_leg  proc     ;it put third digit in its variabe in the data  and dont return something
;waiting for third digit key
   check_for_third_digit:
    mov ah,0
    int 16h                        ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    cmp ah,3eh
    jnz not3_f4 
    jmp label_score_screen
not3_f4:
    ;jz check_for_third_digit
    sub al,30h
    mov ah,0
    ;mov second_column_leg,ax
    mov my_command[3],al
    mov ah,2
    add al,30h
    mov dl,al
    int 21h

    call clearing_buffer
ret
get_second_column_leg endp

get_second_row_leg  proc              ;it put fourth digit in its variabe in the data  and dont return something
;waiting for fourth digit key
   check_for_fourth_digit:
    mov ah,0
    int 16h                        ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    cmp ah,3eh
    jnz not4_f4 
    jmp label_score_screen
not4_f4:
    ;jz check_for_fourth_digit
    sub al,30h
    mov ah,0
    ;mov second_row_leg,ax
    mov my_command[4],al
    mov ah,2
    add al,30h
    mov dl,al
    int 21h

    call clearing_buffer
ret
get_second_row_leg endp

get_output_column proc          ;saving the fifth digit in its variable in data
;waiting for column number
   check_for_output_column:
    mov ah,0
    int 16h   ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    cmp ah,3eh
    jnz not5_f4 
    jmp label_score_screen
not5_f4:
    ;jz check_for_output_column
    sub al,30h
    mov ah,0
    ;mov output_column,ax
    mov my_command[5],al
    mov ah,2
    add al,30h
    mov dl,al
    int 21h

    call clearing_buffer
ret
get_output_column endp

get_output_row proc        ;saving the sixth digit in its variable in data
check_for_output_row:
    mov ah,0
    int 16h   ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    cmp ah,3eh
    jnz not6_f4 
    jmp label_score_screen
not6_f4:
    ;jz check_for_output_row
    sub al,30h
    mov ah,0
    ;mov output_row,ax
    mov my_command[6],al
    mov ah,2
    add al,30h
    mov dl,al
    int 21h

    mov ah,3
    mov bh,0
    int 10h

    mov ah,2
    mov bh,0
    add dl,1
    int 10h

    call clearing_buffer
ret
get_output_row endp


column0_inputs proc   ;if inputs in column 0 so it make the opertion required and put result in column 1,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op                 ; check or operation
    mov bx,first_row_leg            ;bx will take the first leg co_ordinate
    mov al,arr_col0[bx]            ;al will take the input at the first leg in arr0
    mov temp_gates,al               ;temp_gates will keep this input
    mov bx,second_row_leg           ;nw bx will take the second leg co_ordinate
    mov al,arr_col0[bx]           ;al will take the input at the second leg in arr0
    and temp_gates,al               ;and operation occur between two inputs and result in temp_gates
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    mov al,temp_gates               ;al hold the result
    mov arr_col1[bx],al            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position       ;after that continue the main code
check_or_op:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op
    mov bx,first_row_leg
    mov al,arr_col0[bx]
    mov temp_gates,al                  ;same as before but with or operation
    mov bx,second_row_leg
    mov al,arr_col0[bx]
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col1[bx],al
    jmp go_to_output_position
check_nand_op:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op
    mov bx,first_row_leg
    mov al,arr_col0[bx]
    mov temp_gates,al
    mov bx,second_row_leg
    mov al,arr_col0[bx]              ; ;same as before but with nand operation
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col1[bx],al
    jmp go_to_output_position
check_nor_op:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op
    mov bx,first_row_leg
    mov al,arr_col0[bx]
    mov temp_gates,al
    mov bx,second_row_leg
    mov al,arr_col0[bx]
    or temp_gates,al                         ;same as before but with nor operation
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col1[bx],al
    jmp go_to_output_position
check_xor_op:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op
    mov bx,first_row_leg
    mov al,arr_col0[bx]
    mov temp_gates,al
    mov bx,second_row_leg
    mov al,arr_col0[bx]                     ;same as before but with xor operation
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col1[bx],al
    jmp go_to_output_position
check_xnor_op:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op
    mov bx,first_row_leg
    mov al,arr_col0[bx]
    mov temp_gates,al
    mov bx,second_row_leg
    mov al,arr_col0[bx]                 ;same as before but with xnor operation
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col1[bx],al
    jmp go_to_output_position


    check_not_op:
    cmp gate_number,14h    ;letter n for not has scancode 14h
    jnz check_remove_op
    mov bx,first_row_leg
    mov al,arr_col0[bx]                 
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col1[bx],al
    jmp go_to_output_position


    check_remove_op:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz check_wire_op
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire
    mov arr_col1[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position
    specail_for_wire:
    mov arr_col2[bx],5
    jmp go_to_output_position

    check_wire_op:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz go_to_output_position
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff_2
    mov bx,first_row_leg
    mov al,arr_col0[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col1[bx],al
    jmp go_to_output_position
    diff_2:
    mov bx,first_row_leg
    mov al,arr_col0[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col2[bx],al
    jmp go_to_output_position






go_to_output_position:
pop bx
pop ax
ret
column0_inputs endp

column1_inputs proc      ;if inputs in column 1 so it make the opertion required and put result in column 2,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                  ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op1                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz  undefined1
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz  undefined1
;not_undefined
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col2[bx],al
    jmp go_to_output_position1
undefined1:    jmp turn_off2
check_or_op1:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op1
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz undefined2
;not_undefined
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz undefined2
;not_undefined
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col2[bx],al
    jmp go_to_output_position1
undefined2:    jmp turn_off2
check_nand_op1:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op1
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz undefined3
;not_undefined
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz undefined3
;not_undefined
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col2[bx],al
    jmp go_to_output_position1
check_nor_op1:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op1
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz undefined3
;not_undefined
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz undefined3
;not_undefined
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col2[bx],al
    jmp go_to_output_position1
undefined3:jmp turn_off2
check_xor_op1:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op1
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz turn_off2
;not_undefined
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz turn_off2
;not_undefined
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col2[bx],al
    jmp go_to_output_position1
check_xnor_op1:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op1
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz turn_off2
;not_undefined
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz turn_off2
;not_undefined
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col2[bx],al
    jmp go_to_output_position1

turn_off2: jmp put_5


check_not_op1:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op1
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col1[bx]
    cmp al,5
    jz  put_5
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col2[bx],al
    jmp go_to_output_position1

    check_wire_op1:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op1
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff1_2
    mov bx,first_row_leg
    dec bx
    mov al,arr_col1[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col2[bx],al
    jmp go_to_output_position1
    diff1_2:
    mov bx,first_row_leg
    dec bx
    mov al,arr_col1[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col3[bx],al
    jmp go_to_output_position1

    check_remove_op1:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position1

put_5:
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire1
    mov arr_col2[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position1
    specail_for_wire1:
    mov arr_col3[bx],5
    jmp go_to_output_position1

go_to_output_position1:
pop bx
pop ax
ret
column1_inputs endp

column2_inputs proc      ;if inputs in column 2 so it make the opertion required and put result in column 3,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                        ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op2                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined1_col2
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined1_col2
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col3[bx],al
    jmp go_to_output_position2
 undefined1_col2:
    jmp turn_off3
check_or_op2:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op2
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined2_col2
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined2_col2
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col3[bx],al
    jmp go_to_output_position2
undefined2_col2:
    jmp turn_off3
check_nand_op2:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op2
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined3_col2
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined3_col2
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col3[bx],al
    jmp go_to_output_position2
undefined3_col2:
    jmp turn_off3
check_nor_op2:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op2
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined4_col2
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined4_col2
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col3[bx],al
    jmp go_to_output_position2
undefined4_col2:
    jmp turn_off3
check_xor_op2:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op2
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined5_col2
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined5_col2
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col3[bx],al
    jmp go_to_output_position2
undefined5_col2:
    jmp turn_off3
check_xnor_op2:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op2
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined6_col2
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz undefined6_col2
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col3[bx],al
    jmp go_to_output_position2
undefined6_col2:
    jmp turn_off3

    
    check_not_op2:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op2
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col2[bx]
    cmp al,5
    jz  turn_off3
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col3[bx],al
    jmp go_to_output_position2



    check_wire_op2:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op2
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff2_2
    mov bx,first_row_leg
    dec bx
    mov al,arr_col2[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col3[bx],al
    jmp go_to_output_position2
    diff2_2:
    mov bx,first_row_leg
    dec bx
    mov al,arr_col2[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col4[bx],al
    jmp go_to_output_position2

    check_remove_op2:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position2
turn_off3:
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire2
    mov arr_col3[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position2
    specail_for_wire2:
    mov arr_col4[bx],5
go_to_output_position2:
pop bx
pop ax
ret
column2_inputs endp

column3_inputs proc      ;if inputs in column 3 so it make the opertion required and put result in column 4,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                           ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op3                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined1_col3
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined1_col3
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col4[bx],al
    jmp go_to_output_position3
undefined1_col3:
    jmp turn_off4
check_or_op3:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op3
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined2_col3
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col3[bx]
     cmp al,5
    jz undefined2_col3
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col4[bx],al
    jmp go_to_output_position3
undefined2_col3:
    jmp turn_off4
check_nand_op3:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op3
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col3[bx]
     cmp al,5
    jz undefined3_col3
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined3_col3
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col4[bx],al
    jmp go_to_output_position3
 undefined3_col3:
    jmp turn_off4
check_nor_op3:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op3
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined4_col3
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined4_col3
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col4[bx],al
    jmp go_to_output_position3
undefined4_col3:
    jmp turn_off4
check_xor_op3:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op3
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined5_col3
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined5_col3
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col4[bx],al
    jmp go_to_output_position3
undefined5_col3:
    jmp turn_off4
check_xnor_op3:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op3
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined6_col3
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz undefined6_col3
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col4[bx],al
    jmp go_to_output_position3
undefined6_col3:
    jmp turn_off4



    check_not_op3:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op3
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col3[bx]
    cmp al,5
    jz  turn_off4
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col4[bx],al
    jmp go_to_output_position3

    check_wire_op3:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op3
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff3_2
    mov bx,first_row_leg
    dec bx
    mov al,arr_col3[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col4[bx],al
    jmp go_to_output_position3
    diff3_2:
    mov bx,first_row_leg
    dec bx
    mov al,arr_col3[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col5[bx],al
    jmp go_to_output_position3

    check_remove_op3:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position3
turn_off4:
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire3
    mov arr_col4[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position3
    specail_for_wire3:
    mov arr_col5[bx],5
go_to_output_position3:
pop bx
pop ax
ret
column3_inputs endp

column4_inputs proc      ;if inputs in column 4 so it make the opertion required and put result in column 5,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                          ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op4                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined1_col4
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined1_col4
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col5[bx],al
    jmp go_to_output_position4
undefined1_col4:
    jmp turn_off5
check_or_op4:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op4
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined2_col4
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined2_col4
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col5[bx],al
    jmp go_to_output_position4
 undefined2_col4:
    jmp turn_off5
check_nand_op4:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op4
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined3_col4
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined3_col4
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col5[bx],al
    jmp go_to_output_position4
 undefined3_col4:
    jmp turn_off5
check_nor_op4:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op4
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined4_col4
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined4_col4
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col5[bx],al
    jmp go_to_output_position4
 undefined4_col4:
    jmp turn_off5
check_xor_op4:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op4
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined5_col4
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz undefined5_col4
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col5[bx],al
    jmp go_to_output_position4
 undefined5_col4:
    jmp turn_off5
check_xnor_op4:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op4
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col4[bx]
     cmp al,5
    jz undefined6_col4
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col4[bx]
     cmp al,5
    jz undefined6_col4
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col5[bx],al
    jmp go_to_output_position4
 undefined6_col4:
    jmp turn_off5


    check_not_op4:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op4
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col4[bx]
    cmp al,5
    jz  turn_off5
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col5[bx],al
    jmp go_to_output_position4

    check_wire_op4:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op4
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff4_2
    mov bx,first_row_leg
    dec bx
    mov al,arr_col4[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col5[bx],al
    jmp go_to_output_position4
    diff4_2:
    mov bx,first_row_leg
    dec bx
    mov al,arr_col4[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col6[bx],al
    jmp go_to_output_position4

    check_remove_op4:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position4
turn_off5:
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire4
    mov arr_col5[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position4
    specail_for_wire4:
    mov arr_col6[bx],5
go_to_output_position4:
pop bx
pop ax
ret
column4_inputs endp

column5_inputs proc      ;if inputs in column 5 so it make the opertion required and put result in column 6,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                         ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op5                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined1_col5
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined1_col5
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col6[bx],al
    jmp go_to_output_position5
undefined1_col5:
    jmp turn_off6
check_or_op5:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op5
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined2_col5
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined2_col5
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col6[bx],al
    jmp go_to_output_position5
 undefined2_col5:
   jmp turn_off6
check_nand_op5:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op5
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined3_col5
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined3_col5
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col6[bx],al
    jmp go_to_output_position5
 undefined3_col5:
    jmp turn_off6
check_nor_op5:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op5
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined4_col5
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined4_col5
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col6[bx],al
    jmp go_to_output_position5
  undefined4_col5:
    jmp turn_off6
check_xor_op5:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op5
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined5_col5
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined5_col5
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col6[bx],al
    jmp go_to_output_position5
 undefined5_col5:
    jmp turn_off6
check_xnor_op5:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op5
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined6_col5
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz undefined6_col5
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col6[bx],al
    jmp go_to_output_position5
 undefined6_col5:
    jmp turn_off6


    check_not_op5:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op5
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col5[bx]
    cmp al,5
    jz  turn_off6
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col6[bx],al
    jmp go_to_output_position5


    check_wire_op5:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op5
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff5_2
    mov bx,first_row_leg
    dec bx
    mov al,arr_col5[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col6[bx],al
    jmp go_to_output_position5
    diff5_2:
    mov bx,first_row_leg
    dec bx
    mov al,arr_col5[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col7[bx],al
    jmp go_to_output_position5

    check_remove_op5:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position5
turn_off6:
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire5
    mov arr_col6[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position5
    specail_for_wire5:
    mov arr_col7[bx],5
go_to_output_position5:
pop bx
pop ax
ret
column5_inputs endp

column6_inputs proc      ;if inputs in column 6 so it make the opertion required and put result in column 7,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                          ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op6                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined1_col6
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined1_col6
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col7[bx],al
    jmp go_to_output_position6
 undefined1_col6:
    jmp turn_off7
check_or_op6:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op6
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined2_col6
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined2_col6
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col7[bx],al
    jmp go_to_output_position6
 undefined2_col6:
    jmp turn_off7
check_nand_op6:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op6
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined3_col6
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined3_col6
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col7[bx],al
    jmp go_to_output_position6
 undefined3_col6:
    jmp turn_off7
check_nor_op6:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op6
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined4_col6
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined4_col6
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col7[bx],al
    jmp go_to_output_position6
 undefined4_col6:
    jmp turn_off7
check_xor_op6:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op6
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined5_col6
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined5_col6
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col7[bx],al
    jmp go_to_output_position6
undefined5_col6:
    jmp turn_off7
check_xnor_op6:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op6
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined6_col6
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz undefined6_col6
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col7[bx],al
    jmp go_to_output_position6
 undefined6_col6:
    jmp turn_off7

    check_not_op6:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op6
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col6[bx]
    cmp al,5
    jz  turn_off7
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col7[bx],al
    jmp go_to_output_position6

     check_wire_op6:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op6
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff6_2
    mov bx,first_row_leg
    dec bx
    mov al,arr_col6[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col7[bx],al
    jmp go_to_output_position6
    diff6_2:
    mov bx,first_row_leg
    dec bx
    mov al,arr_col6[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col8[bx],al
    jmp go_to_output_position6

    check_remove_op6:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position6
turn_off7:
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire6
    mov arr_col7[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position6
    specail_for_wire6:
    mov arr_col8[bx],5
go_to_output_position6:
pop bx
pop ax
ret
column6_inputs endp

column7_inputs proc      ;if inputs in column 7 so it make the opertion required and put result in column 8,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                  ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op7                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined1_col7
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined1_col7
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col8[bx],al
    jmp go_to_output_position7
 undefined1_col7:
    jmp turn_off8
check_or_op7:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op7
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined2_col7
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined2_col7
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col8[bx],al
    jmp go_to_output_position7
undefined2_col7:
   jmp turn_off8
check_nand_op7:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op7
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined3_col7
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined3_col7
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col8[bx],al
    jmp go_to_output_position7
 undefined3_col7:
    jmp turn_off8
check_nor_op7:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op7
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined4_col7
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined4_col7
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col8[bx],al
    jmp go_to_output_position7
 undefined4_col7:
    jmp turn_off8
check_xor_op7:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op7
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined5_col7
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined5_col7
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    mov arr_col8[bx],al
    jmp go_to_output_position7
undefined5_col7:
    jmp turn_off8
check_xnor_op7:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op7
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined6_col7
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz undefined6_col7
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    sub bx,1
    mov al,temp_gates
    xor al,00000001b
    mov arr_col8[bx],al
    jmp go_to_output_position7
 undefined6_col7:
    jmp turn_off8

    check_not_op7:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op7
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col7[bx]
    cmp al,5
    jz  turn_off8
    xor al,00000001b
    mov bx,output_row
    sub bx,1
    mov arr_col8[bx],al
    jmp go_to_output_position7

    check_wire_op7:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op7
    mov ax,output_column
    sub ax,first_column_leg
    cmp ax,1
    jnz diff7_2
    mov bx,first_row_leg
    dec bx
    mov al,arr_col7[bx]
    mov bx,output_row
    sub bx,1
    mov arr_col8[bx],al
    jmp go_to_output_position7
    diff7_2:
    mov bx,first_row_leg
    dec bx
    mov al,arr_col7[bx]
    mov bx,output_row
    mov arr_col9[bx],al
    jmp go_to_output_position7

     check_remove_op7:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position7
turn_off8:
    mov ax,output_column
    sub ax,first_column_leg
    mov bx,output_row               ;bx will take output co_ordinates
    sub bx,1                        ;as there is no row_0 in this column
    cmp ax,1
    jnz specail_for_wire7
    mov arr_col8[bx],5            ;nw the result is saved for the output node in arr1
    jmp go_to_output_position7
    specail_for_wire7:
    mov arr_col9[bx],5
go_to_output_position7:
pop bx
pop ax
ret
column7_inputs endp

column8_inputs proc      ;if inputs in column 8 so it make the opertion required and put result in column 9,it take gatenumber and inputs,outputs of rows and use bx and al for its function
    push ax                        ;same as column_0
    push bx
    cmp gate_number,1eh             ;letter a for and has scancode 1eh
    jnz check_or_op8                 ; check or operation
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined1_col8
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined1_col8
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    mov al,temp_gates
    mov arr_col9[bx],al
    jmp go_to_output_position8
 undefined1_col8:
    jmp turn_off9
check_or_op8:
    cmp gate_number,18h             ;letter o for or has scancode 18h
    jnz check_nand_op8
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined2_col8
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined2_col8
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    mov al,temp_gates
    mov arr_col9[bx],al
    jmp go_to_output_position8
 undefined2_col8:
    jmp turn_off9
check_nand_op8:
    cmp gate_number,20h             ;letter d for nand has scancode 20h
    jnz check_nor_op8
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col8[bx]
     cmp al,5
    jz undefined3_col8
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col8[bx]
     cmp al,5
    jz undefined3_col8
;;not_undefined:
    and temp_gates,al
    mov bx,output_row
    mov al,temp_gates
    xor al,00000001b
    mov arr_col9[bx],al
    jmp go_to_output_position8
 undefined3_col8:
    jmp turn_off9
check_nor_op8:
    cmp gate_number,13h             ;letter r for nor has scancode 13h
    jnz check_xor_op8
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined4_col8
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined4_col8
;;not_undefined:
    or temp_gates,al
    mov bx,output_row
    mov al,temp_gates
    xor al,00000001b
    mov arr_col9[bx],al
    jmp go_to_output_position8
 undefined4_col8:
    jmp turn_off9
check_xor_op8:
    cmp gate_number,2dh    ;letter x for xor has scancode 2dh
    jnz check_xnor_op8
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col8[bx]
     cmp al,5
    jz undefined5_col8
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col8[bx]
     cmp al,5
    jz undefined5_col8
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    mov al,temp_gates
    mov arr_col9[bx],al
    jmp go_to_output_position8
 undefined5_col8:
    jmp turn_off9
check_xnor_op8:
    cmp gate_number,31h    ;letter n for xnor has scancode 31h
    jnz check_not_op8
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined6_col8
;;not_undefined:
    mov temp_gates,al
    mov bx,second_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz undefined6_col8
;;not_undefined:
    xor temp_gates,al
    mov bx,output_row
    mov al,temp_gates
    xor al,00000001b
    mov arr_col9[bx],al
    jmp go_to_output_position8
 undefined6_col8:
    jmp turn_off9

    check_not_op8:
    cmp gate_number,14h    ;letter n for xnor has scancode 31h
    jnz check_wire_op8
    mov bx,first_row_leg
    sub bx,1
    mov al,arr_col8[bx]
    cmp al,5
    jz  turn_off9
    xor al,00000001b
    mov bx,output_row
    mov arr_col9[bx],al
    jmp go_to_output_position8

    check_wire_op8:
    cmp gate_number,11h         ;letter w for remove has scancode 11h
    jnz check_remove_op8
    mov bx,first_row_leg
    dec bx
    mov al,arr_col8[bx]
    mov bx,output_row
    mov arr_col9[bx],al
    jmp go_to_output_position8

    check_remove_op8:
    cmp gate_number,32h    ;letter M for remove has scancode 32h
    jnz go_to_output_position8
turn_off9:
    mov bx,output_row               ;bx will take output co_ordinates
    mov arr_col9[bx],5            ;nw the result is saved for the output node in arr8

go_to_output_position8:
pop bx
pop ax
ret
column8_inputs endp

logic_game proc    ;take the column which the inputs will be and then call the specfic column procedure to make the operation required

    cmp first_column_leg,0
    jnz go_to_column1_inputs
    call column0_inputs
    jmp continue_to_game

    go_to_column1_inputs:
     cmp first_column_leg,1
    jnz go_to_column2_inputs
    call column1_inputs
    jmp continue_to_game

    go_to_column2_inputs:
     cmp first_column_leg,2
    jnz go_to_column3_inputs
    call column2_inputs
    jmp continue_to_game

    go_to_column3_inputs:
    cmp first_column_leg,3
    jnz go_to_column4_inputs
    call column3_inputs
    jmp continue_to_game

    go_to_column4_inputs:
    cmp first_column_leg,4
    jnz go_to_column5_inputs
    call column4_inputs
    jmp continue_to_game

    go_to_column5_inputs:
    cmp first_column_leg,5
    jnz go_to_column6_inputs
    call column5_inputs
    jmp continue_to_game

    go_to_column6_inputs:
    cmp first_column_leg,6
    jnz go_to_column7_inputs
    call column6_inputs
    jmp continue_to_game

    go_to_column7_inputs:
    cmp first_column_leg,7
    jnz go_to_column8_inputs
    call column7_inputs
    jmp continue_to_game

    go_to_column8_inputs:
    cmp first_column_leg,8
    jnz continue_to_game
    call column8_inputs
    jmp continue_to_game

    continue_to_game:
ret
logic_game endp

colour_nodes_odd_column_ones proc ;must call it after logic game  ;colouring if output is one at a node for odd columns except last column ;take cx and dx of the output node if 1
;equations for coloured nodes in odd column ;columns 35(x-1)+37-21+13 ;rows=16(x-1)+15=dx
    ;columns
 push dx
    dec cx
    mov ax,35d
    mul cx
    add ax,29
    mov cx,ax
    pop dx
    ;rows
    mov ax,16d
    dec dx
    mul dx
    add ax,15
    mov dx,ax
    mov si,offset node
    mov al,04
    call Draw_anything
ret
colour_nodes_odd_column_ones endp

colour_nodes_even_column_ones proc ;must call it after logic game  ;colouring if output is one at a node for even columns ;take cx and dx of the output node if 1
;equations for coloured nodes in even column ;columns 35(x-2)+72-21+13 ;rows=16(x-1)+21=dx
    ;columns
 push dx
    dec cx
    dec cx
    mov ax,35d
    mul cx
    add ax,64
    mov cx,ax
    pop dx
    ;rows
    mov ax,16d
    dec dx
    mul dx
    add ax,21
    mov dx,ax
    mov si,offset node
    mov al,04
    call Draw_anything
ret
colour_nodes_even_column_ones endp

colour_nodes_odd_column_zeros proc ;must call it after logic game  ;colouring if output is zero at a node for odd columns except last column ;take cx and dx of the output node if 1
;equations for coloured nodes in odd column ;columns 35(x-1)+37-21+13 ;rows=16(x-1)+15=dx
    ;columns
 push dx
    dec cx
    mov ax,35d
    mul cx
    add ax,29
    mov cx,ax
    pop dx
    ;rows
    mov ax,16d
    dec dx
    mul dx
    add ax,15
    mov dx,ax
    mov si,offset node
    mov al,02
    call Draw_anything
ret
colour_nodes_odd_column_zeros endp

colour_nodes_even_column_zeros proc ;must call it after logic game  ;colouring if output is zero at a node for even columns ;take cx and dx of the output node if 1
;equations for coloured nodes in even column ;columns 35(x-2)+72-21+13 ;rows=16(x-1)+21=dx
    ;columns
 push dx
    dec cx
    dec cx
    mov ax,35d
    mul cx
    add ax,64
    mov cx,ax
    pop dx
    ;rows
    mov ax,16d
    dec dx
    mul dx
    add ax,21
    mov dx,ax
    mov si,offset node
    mov al,02
    call Draw_anything
ret
colour_nodes_even_column_zeros endp

colour_nodes_last_column_zeros proc ;must call it after logic game  ;colouring if output is zero at a node for last column ;take cx and dx of the output node if 1
;equations for coloured nodes in even column ;columns 35(x-2)+72-21+13 ;rows=16(x-1)+21=dx
    ;columns
    mov cx,307d
    ;rows
    cmp dx,0
    jnz not_node_0_zero    ;zero output at node 0
    mov dx,10d
    jmp node_0_zero
 not_node_0_zero:
    mov ax,16d
    dec dx
    mul dx
    add ax,23d
    mov dx,ax
   node_0_zero:
    mov si,offset node_last_column
    mov al,02
    call Draw_anything
ret
colour_nodes_last_column_zeros endp

colour_nodes_last_column_ones proc ;must call it after logic game  ;colouring if output is one at a node for last column ;take cx and dx of the output node if 1
;equations for coloured nodes in even column ;columns 306=cx ;rows=16(x-1)+23 =dx
    ;columns
    mov cx,307d
    ;rows
    cmp dx,0
    jnz not_node_0
    mov dx,10d
    jmp node_0
 not_node_0:
    mov ax,16d
    dec dx
    mul dx
    add ax,23d
    mov dx,ax
   node_0:
    mov si,offset node_last_column
    mov al,04
    call Draw_anything
ret
colour_nodes_last_column_ones endp

colour_nodes_last_column_undefined_my_nodes proc ;must call it after logic game  ;colouring if output is one at a node for last column ;take cx and dx of the output node if 1
;equations for coloured nodes in even column ;columns 307=cx ;rows=16(x-1)+23 =dx
    ;columns
    mov cx,307d
    ;rows
    cmp dx,0
    jnz not_node_0_undefined_my
    mov dx,10d
    jmp node_0_undefined_my
 not_node_0_undefined_my:
    mov ax,16d
    dec dx
    mul dx
    add ax,23d
    mov dx,ax
   node_0_undefined_my:
    mov si,offset node_last_column
    mov al,07
    call Draw_anything
ret
colour_nodes_last_column_undefined_my_nodes endp

undefined_nodes_colour proc ;must call it after logic game  ;colouring if output is one at a node for last column ;take cx and dx of the output node if 1
;equations for coloured nodes in even column ;columns 307=cx ;rows=16(x-1)+23 =dx
    ;columns
    mov cx,307d
    ;rows
    mov ax,16d
    dec dx
    mul dx
    add ax,23d
    mov dx,ax
    mov si,offset node_last_column
    mov al,09h
    call Draw_anything
ret
undefined_nodes_colour endp


colour_nodes_odd_column_undefined proc ;must call it after logic game  ;colouring if output is one at a node for odd columns except last column ;take cx and dx of the output node if 1
;equations for coloured nodes in odd column ;columns 35(x-1)+37-21+13 ;rows=16(x-1)+15=dx
    ;columns
 push dx
    dec cx
    mov ax,35d
    mul cx
    add ax,29
    mov cx,ax
    pop dx
    ;rows
    mov ax,16d
    dec dx
    mul dx
    add ax,15
    mov dx,ax
    mov si,offset node
    mov al,00
    call Draw_anything
ret
colour_nodes_odd_column_undefined endp

colour_nodes_even_column_undefined proc ;must call it after logic game  ;colouring if output is zero at a node for even columns ;take cx and dx of the output node if 1
;equations for coloured nodes in even column ;columns 35(x-2)+72-21+13 ;rows=16(x-1)+21=dx
    ;columns
 push dx
    dec cx
    dec cx
    mov ax,35d
    mul cx
    add ax,64
    mov cx,ax
    pop dx
    ;rows
    mov ax,16d
    dec dx
    mul dx
    add ax,21
    mov dx,ax
    mov si,offset node
    mov al,00
    call Draw_anything
ret
colour_nodes_even_column_undefined endp

check_for_any_ones_to_colour proc
mov cx,9
    mov bx,0
arr_1:
    cmp arr_col1[bx],1
    jz col1
repeat: add bx,1
    loop arr_1
    inc temp_find_?_columns             ;intialize=1
    cmp temp_find_?_columns,9
    jnz temp_not_9
    mov cx,10
    jmp arr_1
 temp_not_9:
    mov cx,9

    cmp temp_find_?_columns,10
    jz end_1
    jmp arr_1


 col1: cmp temp_find_?_columns,1
  jnz col2
  mov dx,bx
  add dx,1d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  col2:

  cmp temp_find_?_columns,2
  jnz col3
  mov dx,bx
  sub dx,8
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  col3:
  cmp temp_find_?_columns,3
  jnz col4
  mov dx,bx
  sub dx,17d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  end_1:jmp end_2
  col4:
  cmp temp_find_?_columns,4
  jnz col5
  mov dx,bx
  sub dx,26d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  col5:
  cmp temp_find_?_columns,5
  jnz col6
   mov dx,bx
  sub dx,35d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  col6:
  cmp temp_find_?_columns,6
  jnz col7
  mov dx,bx
  sub dx,44d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  col7:
  cmp temp_find_?_columns,7
  jnz col8
  mov dx,bx
  sub dx,53d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  end_2:jmp end_
  col8:
  cmp temp_find_?_columns,8
  jnz col9
  mov dx,bx
  sub dx,62d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  col9:
  cmp temp_find_?_columns,9
  jnz col10
  mov dx,bx
  sub dx,72d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_last_column_ones
  pop cx
  pop bx
  pop ax
  jmp repeat
  col10:

    end_:  mov temp_find_?_columns,1

ret
check_for_any_ones_to_colour endp

check_for_any_zeros_to_colour proc
    mov cx,9
    mov bx,0
arr_1_0:
    cmp arr_col1[bx],0
    jz col1_0
repeat_0: add bx,1
    loop arr_1_0
    inc temp_find_?_columns
    cmp temp_find_?_columns,9
    jnz temp_not_9_0
    mov cx,10
    jmp arr_1_0
 temp_not_9_0:
    mov cx,9

    cmp temp_find_?_columns,10
    jz end_1_0
    jmp arr_1_0


 col1_0: cmp temp_find_?_columns,1
  jnz col2_0
  mov dx,bx
  add dx,1
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  col2_0:

  cmp temp_find_?_columns,2
  jnz col3_0
  mov dx,bx
  sub dx,8
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  col3_0:
  cmp temp_find_?_columns,3
  jnz col4_0
  mov dx,bx
  sub dx,17
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  end_1_0:jmp end_2_0
  col4_0:
  cmp temp_find_?_columns,4
  jnz col5_0
  mov dx,bx
  sub dx,26
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  col5_0:
  cmp temp_find_?_columns,5
  jnz col6_0
   mov dx,bx
  sub dx,35
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  col6_0:
  cmp temp_find_?_columns,6
  jnz col7_0
  mov dx,bx
  sub dx,44
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  col7_0:
  cmp temp_find_?_columns,7
  jnz col8_0
  mov dx,bx
  sub dx,53
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  end_2_0:jmp end_0
  col8_0:
  cmp temp_find_?_columns,8
  jnz col9_0
  mov dx,bx
  sub dx,62
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  col9_0:
  cmp temp_find_?_columns,9
  jnz col10_0
  mov dx,bx
  sub dx,72d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_last_column_zeros
  pop cx
  pop bx
  pop ax
  jmp repeat_0
  col10_0:

    end_0:  mov temp_find_?_columns,1

ret
check_for_any_zeros_to_colour endp

remove_upper_wire_for_gates proc

wire_down_remove:

    call output_position
    mov ax,dx        ;nhaya
    add ax,6d
    push ax
    call input_position_upper_leg
    mov bx,dx        ;bdaya
    pop ax
    mov temp_wire_rows,ax
    cmp bx,ax
    ja wire_up_remove
    mov bh,0h
    mov al,0fh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire_remove:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire_remove
vertical_wire_remove:
    inc dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire_remove

    horizontal2_wire_remove:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire_remove

    jmp done_wiring_remove
    wire_up_remove:
    mov bh,0h
    mov al,0fh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire1_remove:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire1_remove
vertical_wire1_remove:
    dec dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire1_remove

    horizontal2_wire1_remove:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire1_remove

    done_wiring_remove:

ret
remove_upper_wire_for_gates endp

remove_lower_wire_for_gates proc

wire_down1_remove:

    call output_position
    mov ax,dx        ;nhaya
    add ax,10d
    push ax
    call input_position_lower_leg  ;
    mov bx,dx        ;bdaya
    pop ax
    mov temp_wire_rows,ax
    cmp bx,ax
    ja wire_up1_remove
    mov bh,0h
    mov al,0fh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire2_remove:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire2_remove
vertical_wire2_remove:
    inc dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire2_remove

    horizontal2_wire2_remove:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire2_remove

    jmp done_wiring1_remove
    wire_up1_remove:
    mov bh,0h
    mov al,0fh          ;Pixel color
    mov ah,0ch          ;Draw Pixel Command
    horizontal_wire3_remove:  int 10h
    inc cx
    cmp cx,temp_wire_horizontal_1
    jnz horizontal_wire3_remove
vertical_wire3_remove:
    dec dx
    cmp dx,temp_wire_rows
    int 10h
    jnz vertical_wire3_remove

    horizontal2_wire3_remove:
    inc cx
    cmp cx,temp_wire_horizontal_2
    int 10h
    jnz horizontal2_wire3_remove

    done_wiring1_remove:

ret
remove_lower_wire_for_gates endp

display_message_error proc
    mov ah,9
    mov dx,offset error_message
    int 21h
ret
display_message_error endp

removing_gates proc  ;it takes gate number to check if it is command M or not  and it draws all gates in the position needed and it puts undefined=5 in the arr[column] that is removed
    cmp gate_number,32h               ;letter M has scancode 32h
    jnz not_remove_command

    call output_position

    push cx
    push dx
    mov si,offset and_gate
    mov al,0fh                       ;colur white
    call Draw_anything
    pop dx
    pop cx


    push cx
    push dx
    mov si,offset or_gate
    mov al,0fh                       ;colur white
    call Draw_anything
    pop dx
    pop cx

    push cx
    push dx
    mov si,offset xor_gate
    mov al,0fh                       ;colur white
    call Draw_anything
    pop dx
    pop cx

    push cx
    push dx
    mov si,offset nand_gate
    mov al,0fh                       ;colur white
    call Draw_anything
    pop dx
    pop cx

    push cx
    push dx
    mov si,offset nor_gate
    mov al,0fh                       ;colur white
    call Draw_anything
    pop dx
    pop cx

    push cx
    push dx
    mov si,offset xnor_gate
    mov al,0fh                       ;colur white
    call Draw_anything
    pop dx
    pop cx

    push cx
    push dx
    mov si,offset not_gate
    mov al,0fh                       ;colur white
    call Draw_anything
    pop dx
    pop cx


    call remove_upper_wire_for_gates
    call remove_lower_wire_for_gates
    call remove_wire_command
    call draw_numbers
    call first_second_horizontal
    call the_8_vertical_lines
    jmp start_loop1

    not_remove_command:jmp close

start_loop1:
;save the co-ordinate of the removed gate to get rid off it from the funniest array
  mov ax,first_row_leg
  mov remove_first_row_leg,ax
  mov ax,second_row_leg
  mov remove_second_row_leg,ax
  mov ax,output_row
  mov remove_output_row,ax
  mov ax,first_column_leg
  mov remove_first_column_leg,ax

  mov ax,output_column
  mov remove_output_column,ax
  mov ax,second_column_leg
  mov remove_second_column_leg,ax
 

 



    mov bx,0
    mov cx,891d
    mov ah,0
    ; cmp output_column,1
    ; jnz  start_loop2      ;

finding_the_target_cordinate:
    mov ax,remove_first_row_leg
    cmp al,saved_col1[bx]
    jz  check_next
    jmp continue_searching

    check_next:
    mov ax,remove_second_row_leg
    cmp al,saved_col1[bx+1]
    jz  check_next1
    jmp continue_searching


    check_next1:
    mov ax,remove_output_row
    cmp al,saved_col1[bx+2]
    jz  check_next2
    jmp continue_searching




    check_next2:
    mov ax,remove_first_column_leg
    cmp al,saved_col1[bx+3]
    jz  check_next3
    jmp continue_searching


  check_next3:
    mov ax,remove_output_column
    cmp al,saved_col1[bx+4]
    jz  check_next4
    jmp continue_searching


    check_next4:
    mov ax,remove_second_column_leg
    cmp al,saved_col1[bx+5]
    jz  make_all_undefined
    jmp continue_searching


make_all_undefined:

    mov saved_col1[bx-1],"$"
    mov saved_col1[bx],"$"
    mov saved_col1[bx+1],"$"
    mov saved_col1[bx+2],"$"
    mov saved_col1[bx+3],"$"
    mov saved_col1[bx+4],"$"
    mov saved_col1[bx+5],"$"
    jmp i_found_it

    continue_searching:
    inc bx
    loop finding_the_target_cordinate
    call display_message_error
    i_found_it:




close:
ret
removing_gates endp


check_for_any_undfined5_to_colour proc;function which loop about all arrays of columns to get the undefined and coloured it with black
mov cx,9                   ;size of arrays from column 1 to 8
    mov bx,0
arr_1_5:
    cmp arr_col1[bx],5              ;5 = undefined
    jz col1_5
repeat_5: add bx,1
    loop arr_1_5
    inc temp_find_?_columns
    cmp temp_find_?_columns,9
    jnz temp_not_9_5
    mov cx,10                       ;because column nine is 10 nodes
    jmp arr_1_5
 temp_not_9_5:                     ;if not column nine so the size =9
    mov cx,9

    cmp temp_find_?_columns,10        ;there is no column 10 so get out from the procedure
    jz end_1_5
    jmp arr_1_5


 col1_5: cmp temp_find_?_columns,1
  jnz col2_5
  mov dx,bx
  add dx,1
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  col2_5:

  cmp temp_find_?_columns,2
  jnz col3_5
  mov dx,bx
  sub dx,8
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  col3_5:
  cmp temp_find_?_columns,3
  jnz col4_5
  mov dx,bx
  sub dx,17
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  end_1_5:jmp end_2_5
  col4_5:
  cmp temp_find_?_columns,4
  jnz col5_5
  mov dx,bx
  sub dx,26
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  col5_5:
  cmp temp_find_?_columns,5
  jnz col6_5
   mov dx,bx
  sub dx,35
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  col6_5:
  cmp temp_find_?_columns,6
  jnz col7_5
  mov dx,bx
  sub dx,44
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  col7_5:
  cmp temp_find_?_columns,7
  jnz col8_5
  mov dx,bx
  sub dx,53
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_odd_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  end_2_5:jmp end_5
  col8_5:
  cmp temp_find_?_columns,8
  jnz col9_5
  mov dx,bx
  sub dx,62
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  call colour_nodes_even_column_undefined
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  col9_5:
  cmp temp_find_?_columns,9
  jnz col10_5
  mov dx,bx
  sub dx,72d
  push ax
  push bx
  push cx
  mov cx,temp_find_?_columns
  cmp dx,4          ;?????????????????????????????????????   hna feh 7aga n2saaaa
  ja my_opponnet
  call colour_nodes_last_column_undefined_my_nodes
  jmp finished
my_opponnet:
  call undefined_nodes_colour
finished:
  pop cx
  pop bx
  pop ax
  jmp repeat_5
  col10_5:

    end_5:  mov temp_find_?_columns,1


ret
check_for_any_undfined5_to_colour endp

randomize_values_first_col proc
;colouring first column with random values
    mov di,1
    mov ah,2ch
    int 21h
    mov cl,5
    ror dl,cl
    cmp dl,128d
    ja  green_first

    red_first:
    mov arr_col0[0],1
     jmp colour_first_node

green_first:
     mov arr_col0[0],0

 colour_first_node:
    mov ah,2ch
    int 21h
    mov timer,dl
    time:
    mov cl,5
    ror timer,cl
    cmp timer,128d
    ja  green
red:
    mov arr_col0[di],1
    inc di                 
    cmp di,10d
    jnz time
    jmp end_colouring
green:
    mov arr_col0[di],0
    inc di
    cmp di,10d
    jnz time



 end_colouring:
ret
randomize_values_first_col endp

draw_first_col_nodes proc
cmp arr_col0[0],0
jnz draw_red_first
    mov cx,0d         ;Column
    mov dx,18d       ;Row
    mov bh,0h
    mov al,02h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
 first_node_colouring:   int 10h
    inc cx
    cmp cx,10d
    jnz first_node_colouring
    jmp ba2y_L_nodes
draw_red_first:
    mov cx,0d         ;Column
    mov dx,18d       ;Row
    mov bh,0h
    mov al,04h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
 first_node_colouring2:   int 10h
    inc cx
    cmp cx,10d
    jnz first_node_colouring2

ba2y_L_nodes:
mov bx,1
;mov di,9
mov si,31d
ebd2_compare:
cmp arr_col0[bx],0
jnz draw_red_node
    mov cx,0d         ;Column
    mov dx,si       ;Row
    mov bh,0h
    mov al,02h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
 nodes_colouring:   int 10h
    inc cx
    cmp cx,10d
    jnz nodes_colouring
    inc bx
    add si,16d
    cmp si,175d
    jnz ebd2_compare
    jmp end_ba2y_colouring

draw_red_node:
    mov cx,0d         ;Column
    mov dx,si       ;Row
    mov bh,0h
    mov al,04h         ;Pixel color
    mov ah,0ch       ;Draw Pixel Command
 nodes_colouring_red:   int 10h
    inc cx
    cmp cx,10d
    jnz nodes_colouring_red
    inc bx
    add si,16d
    cmp si,175d
    jnz ebd2_compare

end_ba2y_colouring:

ret
draw_first_col_nodes endp

re_calculate_logic proc

   mov cx,16d
   mov bx,0
stored_gate_col1:
   cmp saved_col1[bx],"$"    ;99   0 l 98
   jz  not_a_gate0
   mov ah,0
   mov al,saved_col1[bx]
   mov gate_number,al
   mov al,saved_col1[bx+1]
   mov first_row_leg,ax
   mov al,saved_col1[bx+2]
   mov second_row_leg,ax
   mov al,saved_col1[bx+3]
   mov output_row,ax
   mov al,saved_col1[bx+4]
   mov first_column_leg,ax
   mov al,saved_col1[bx+5]
   mov output_column,ax
   mov al,saved_col1[bx+6]
   mov second_column_leg,ax
   add  bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate0:
   inc bx
   loop stored_gate_col1

   mov cx,16d
   mov bx,0
stored_gate_col2:
   cmp saved_col2[bx],"$"    ;99   0 l 98
   jz  not_a_gate
   mov ah,0
   mov al,saved_col2[bx]
   mov gate_number,al
   mov al,saved_col2[bx+1]
   mov first_row_leg,ax
   mov al,saved_col2[bx+2]
   mov second_row_leg,ax
   mov al,saved_col2[bx+3]
   mov output_row,ax
   mov al,saved_col2[bx+4]
   mov first_column_leg,ax
   mov al,saved_col2[bx+5]
   mov output_column,ax
   mov al,saved_col2[bx+6]
   mov second_column_leg,ax
   add  bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate:
   inc bx
   loop stored_gate_col2

   mov cx,16
   mov bx,0
stored_gate_col3:
   cmp saved_col3[bx],"$"
   jz  not_a_gate1
   mov ah,0
   mov al,saved_col3[bx]
   mov gate_number,al
   mov al,saved_col3[bx+1]
   mov first_row_leg,ax
   mov al,saved_col3[bx+2]
   mov second_row_leg,ax
   mov al,saved_col3[bx+3]
   mov output_row,ax
   mov al,saved_col3[bx+4]
   mov first_column_leg,ax
   mov al,saved_col3[bx+5]
   mov output_column,ax
   mov al,saved_col3[bx+6]
   mov second_column_leg,ax
   add bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate1:
   inc bx
   loop stored_gate_col3

   mov cx,16d
   mov bx,0
stored_gate_col4:
   cmp saved_col4[bx],"$"
   jz  not_a_gate2
   mov ah,0
   mov al,saved_col4[bx]
   mov gate_number,al
   mov al,saved_col4[bx+1]
   mov first_row_leg,ax
   mov al,saved_col4[bx+2]
   mov second_row_leg,ax
   mov al,saved_col4[bx+3]
   mov output_row,ax
   mov al,saved_col4[bx+4]
   mov first_column_leg,ax
   mov al,saved_col4[bx+5]
   mov output_column,ax
   mov al,saved_col4[bx+6]
   mov second_column_leg,ax
   add bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate2:
   inc bx
   loop stored_gate_col4


   mov cx,16
   mov bx,0
stored_gate_col5:
   cmp saved_col5[bx],"$"
   jz  not_a_gate3
   mov ah,0
   mov al,saved_col5[bx]
   mov gate_number,al
   mov al,saved_col5[bx+1]
   mov first_row_leg,ax
   mov al,saved_col5[bx+2]
   mov second_row_leg,ax
   mov al,saved_col5[bx+3]
   mov output_row,ax
   mov al,saved_col5[bx+4]
   mov first_column_leg,ax
   mov al,saved_col5[bx+5]
   mov output_column,ax
   mov al,saved_col5[bx+6]
   mov second_column_leg,ax
   add bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate3:
   inc bx
   loop stored_gate_col5


   mov cx,16d
   mov bx,0
stored_gate_col6:
   cmp saved_col6[bx],"$"
   jz  not_a_gate4
   mov ah,0
   mov al,saved_col6[bx]
   mov gate_number,al
   mov al,saved_col6[bx+1]
   mov first_row_leg,ax
   mov al,saved_col6[bx+2]
   mov second_row_leg,ax
   mov al,saved_col6[bx+3]
   mov output_row,ax
   mov al,saved_col6[bx+4]
   mov first_column_leg,ax
   mov al,saved_col6[bx+5]
   mov output_column,ax
   mov al,saved_col6[bx+6]
   mov second_column_leg,ax
   add bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate4:
   inc bx
   loop stored_gate_col6

   mov cx,16d
   mov bx,0
stored_gate_col7:
   cmp saved_col7[bx],"$"
   jz  not_a_gate5
   mov ah,0
   mov al,saved_col7[bx]
   mov gate_number,al
   mov al,saved_col7[bx+1]
   mov first_row_leg,ax
   mov al,saved_col7[bx+2]
   mov second_row_leg,ax
   mov al,saved_col7[bx+3]
   mov output_row,ax
   mov al,saved_col7[bx+4]
   mov first_column_leg,ax
   mov al,saved_col7[bx+5]
   mov output_column,ax
   mov al,saved_col7[bx+6]
   mov second_column_leg,ax
   add bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate5:
   inc bx
   loop stored_gate_col7

   mov cx,16d
   mov bx,0
stored_gate_col8:
   cmp saved_col8[bx],"$"
   jz  not_a_gate6
   mov ah,0
   mov al,saved_col8[bx]
   mov gate_number,al
   mov al,saved_col8[bx+1]
   mov first_row_leg,ax
   mov al,saved_col8[bx+2]
   mov second_row_leg,ax
   mov al,saved_col8[bx+3]
   mov output_row,ax
   mov al,saved_col8[bx+4]
   mov first_column_leg,ax
   mov al,saved_col8[bx+5]
   mov output_column,ax
   mov al,saved_col8[bx+6]
   mov second_column_leg,ax
   add bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate6:
   inc bx
   loop stored_gate_col8

   mov cx,16d
   mov bx,0
stored_gate_col9:
   cmp saved_col9[bx],"$"
   jz  not_a_gate7
   mov ah,0
   mov al,saved_col9[bx]
   mov gate_number,al
   mov al,saved_col9[bx+1]
   mov first_row_leg,ax
   mov al,saved_col9[bx+2]
   mov second_row_leg,ax
   mov al,saved_col9[bx+3]
   mov output_row,ax
   mov al,saved_col9[bx+4]
   mov first_column_leg,ax
   mov al,saved_col9[bx+5]
   mov output_column,ax
   mov al,saved_col9[bx+6]
   mov second_column_leg,ax
   add bx,6
   push bx
   push cx
   call logic_game
   call output_position
   call which_gate_to_draw
   call draw_numbers
   call first_second_horizontal
   call the_8_vertical_lines
   pop cx
   pop bx
   not_a_gate7:
   inc bx
   loop stored_gate_col9



ret
re_calculate_logic endp

save_the_inputs proc
cmp gate_number,32h
jz dont_save
check_1:
   cmp output_column,1
   jnz  not_found0
   mov bx,counter1
   mov ah,0
   mov al,gate_number
   mov saved_col1[bx],al
   mov ax,first_row_leg
   mov saved_col1 [bx+1],al
   mov ax,second_row_leg
   mov saved_col1 [bx+2],al
   mov ax,output_row
   mov saved_col1 [bx+3],al
   mov ax,first_column_leg
   mov saved_col1 [bx+4],al
   mov ax,output_column
   mov saved_col1[bx+5],al
   mov ax,second_column_leg
   mov saved_col1[bx+6],al
   add counter1,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found0:

  jmp check_2
  dont_save:jmp dont_save_help

check_2:
   cmp output_column,2
   jnz  not_found
   mov bx,counter2
   mov ah,0
   mov al,gate_number
   mov saved_col2[bx],al
   mov ax,first_row_leg
   mov saved_col2 [bx+1],al
   mov ax,second_row_leg
   mov saved_col2 [bx+2],al
   mov ax,output_row
   mov saved_col2 [bx+3],al
   mov ax,first_column_leg
   mov saved_col2 [bx+4],al
   mov ax,output_column
   mov saved_col2[bx+5],al
   mov ax,second_column_leg
   mov saved_col2[bx+6],al
   add counter2,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found:


  check_3:
   cmp output_column,3
   jnz  not_found1
   mov bx,counter3
   mov ah,0
   mov al,gate_number
   mov saved_col3[bx],al
   mov ax,first_row_leg
   mov saved_col3 [bx+1],al
   mov ax,second_row_leg
   mov saved_col3 [bx+2],al
   mov ax,output_row
   mov saved_col3 [bx+3],al
   mov ax,first_column_leg
   mov saved_col3 [bx+4],al
   mov ax,output_column
   mov saved_col3[bx+5],al
   mov ax,second_column_leg
   mov saved_col3[bx+6],al
   add counter3,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found1:


  check_4:
   cmp output_column,4
   jnz  not_found2
   mov bx,counter4
   mov ah,0
   mov al,gate_number
   mov saved_col4[bx],al
   mov ax,first_row_leg
   mov saved_col4 [bx+1],al
   mov ax,second_row_leg
   mov saved_col4 [bx+2],al
   mov ax,output_row
   mov saved_col4 [bx+3],al
   mov ax,first_column_leg
   mov saved_col4 [bx+4],al
   mov ax,output_column
   mov saved_col4[bx+5],al
   mov ax,second_column_leg
   mov saved_col4[bx+6],al
   add counter4,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found2:

  check_5:
   cmp output_column,5
   jnz  not_found3
   mov bx,counter5
   mov ah,0
   mov al,gate_number
   mov saved_col5[bx],al
   mov ax,first_row_leg
   mov saved_col5 [bx+1],al
   mov ax,second_row_leg
   mov saved_col5 [bx+2],al
   mov ax,output_row
   mov saved_col5 [bx+3],al
   mov ax,first_column_leg
   mov saved_col5 [bx+4],al
   mov ax,output_column
   mov saved_col5[bx+5],al
   mov ax,second_column_leg
   mov saved_col5[bx+6],al
   add counter5,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found3:

  check_6:
   cmp output_column,6
   jnz  not_found4
   mov bx,counter6
   mov ah,0
   mov al,gate_number
   mov saved_col6[bx],al
   mov ax,first_row_leg
   mov saved_col6 [bx+1],al
   mov ax,second_row_leg
   mov saved_col6 [bx+2],al
   mov ax,output_row
   mov saved_col6 [bx+3],al
   mov ax,first_column_leg
   mov saved_col6 [bx+4],al
   mov ax,output_column
   mov saved_col6[bx+5],al
   mov ax,second_column_leg
   mov saved_col6[bx+6],al
   add counter6,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found4:

  check_7:
   cmp output_column,7
   jnz  not_found5
   mov bx,counter7
   mov ah,0
   mov al,gate_number
   mov saved_col7[bx],al
   mov ax,first_row_leg
   mov saved_col7 [bx+1],al
   mov ax,second_row_leg
   mov saved_col7 [bx+2],al
   mov ax,output_row
   mov saved_col7 [bx+3],al
   mov ax,first_column_leg
   mov saved_col7 [bx+4],al
   mov ax,output_column
   mov saved_col7[bx+5],al
   mov ax,second_column_leg
   mov saved_col7[bx+6],al
   add counter7,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found5:

  check_8:
   cmp output_column,8
   jnz  not_found6
   mov bx,counter8
   mov ah,0
   mov al,gate_number
   mov saved_col8[bx],al
   mov ax,first_row_leg
   mov saved_col8 [bx+1],al
   mov ax,second_row_leg
   mov saved_col8 [bx+2],al
   mov ax,output_row
   mov saved_col8 [bx+3],al
   mov ax,first_column_leg
   mov saved_col8 [bx+4],al
   mov ax,output_column
   mov saved_col8[bx+5],al
   mov ax,second_column_leg
   mov saved_col8[bx+6],al
   add counter8,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found6:

  check_9:
   cmp output_column,9
   jnz  not_found7
   mov bx,counter9
   mov ah,0
   mov al,gate_number
   mov saved_col9[bx],al
   mov ax,first_row_leg
   mov saved_col9 [bx+1],al
   mov ax,second_row_leg
   mov saved_col9 [bx+2],al
   mov ax,output_row
   mov saved_col9 [bx+3],al
   mov ax,first_column_leg
   mov saved_col9 [bx+4],al
   mov ax,output_column
   mov saved_col9[bx+5],al
   mov ax,second_column_leg
   mov saved_col9[bx+6],al
   add counter9,7                                             ;;;;lma a3ml remove eh l mfrod yt8yr???
  not_found7:
dont_save_help:
ret
save_the_inputs endp

check_overwrite_in_output proc
cmp gate_number,32h
     jz  dont_check_overwrite
     mov ax,output_column

     cmp ax,1
     jnz check_overwrite2
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite1:
     mov ah,0
     cmp al,saved_col1[bx]
     jnz continue_checking
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"   ;"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
     call display_message_error
     jmp dont_check_overwrite
continue_checking:
     add bx,7
     loop loop_check_overwrite1


    dont_check_overwrite:
    jmp get_out

    check_overwrite2:
    cmp ax,2
     jnz check_overwrite3
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite2:
     mov ah,0
     cmp al,saved_col2[bx]
     jnz continue_checking2
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"   ;"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite2
continue_checking2:
     add bx,7
     loop loop_check_overwrite2
    dont_check_overwrite2:
    jmp get_out



check_overwrite3:
     cmp ax,3
     jnz check_overwrite4
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite3:
     mov ah,0
     cmp al,saved_col3[bx]    ;3 10 17
     jnz continue_checking3
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"   ;"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite3
continue_checking3:
     add bx,7
     loop loop_check_overwrite3
    dont_check_overwrite3:
    jmp get_out


    check_overwrite4:
     cmp ax,4
     jnz check_overwrite5
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite4:
     mov ah,0
     cmp al,saved_col4[bx]
     jnz continue_checking4
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite4
continue_checking4:
     add bx,7
     loop loop_check_overwrite4
    dont_check_overwrite4:
    jmp get_out


    check_overwrite5:
    cmp ax,5
     jnz check_overwrite6
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite5:
     mov ah,0
     cmp al,saved_col5[bx]
     jnz continue_checking5
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite5
continue_checking5:
     add bx,7
     loop loop_check_overwrite5
    dont_check_overwrite5:
    jmp get_out


    check_overwrite6:
    cmp ax,6
     jnz check_overwrite7
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite6:
     mov ah,0
     cmp al,saved_col6[bx]
     jnz continue_checking6
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite6
continue_checking6:
     add bx,7
     loop loop_check_overwrite6
    dont_check_overwrite6:
    jmp get_out

    check_overwrite7:
    cmp ax,7
     jnz check_overwrite8
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite7:
     mov ah,0
     cmp al,saved_col7[bx]
     jnz continue_checking7
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite7
continue_checking7:
     add bx,7
     loop loop_check_overwrite7
    dont_check_overwrite7:
    jmp get_out


    check_overwrite8:
    cmp ax,8
     jnz check_overwrite9
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite8:
     mov ah,0
     cmp al,saved_col8[bx]
     jnz continue_checking8
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite8
continue_checking8:
     add bx,7
     loop loop_check_overwrite8
    dont_check_overwrite8:
    jmp get_out



    check_overwrite9:
    cmp ax,9
     jnz get_out
     mov ax,output_row
     mov bx,3
     mov cx,14d
     loop_check_overwrite9:
     mov ah,0
     cmp al,saved_col9[bx]
     jnz continue_checking9
     mov gate_number,"$"       ;garbage value
     mov first_column_leg,"$"
     mov second_column_leg,"$"
     mov first_row_leg,"$"
     mov second_row_leg,"$"
     mov output_column,"$"
     mov output_row,"$"
      call display_message_error
     jmp dont_check_overwrite9
continue_checking9:
     add bx,7
     loop loop_check_overwrite9
    dont_check_overwrite9:
    jmp get_out



get_out:


ret
check_overwrite_in_output endp




check_gate_wire_diff proc
   cmp gate_number,32h
      jz true_command
check_3ady:
    cmp gate_number,11h
    jz  check_wire_diff
check_it_s_not?:
    cmp gate_number,14h
    jz  check_not_diff

    mov ax,output_column                     ;38 00 45 55
    sub ax,first_column_leg
    cmp ax,1
    jnz display_error
check_input_two:
    mov ax,output_column
    sub ax,second_column_leg
    cmp ax,1
    jnz display_error
    jmp true_command

check_wire_diff:
    mov ax,output_column                     ;38 00 45 55
    sub ax,first_column_leg
    cmp ax,1
    jz  true_command
    cmp ax,2
    jz true_command
    jmp display_error

    check_not_diff:
    mov ax,output_column                     ;38 00 45 55
    sub ax,first_column_leg
    cmp ax,1
    jz  true_command
    jmp display_error

    display_error:jmp display_ll_error

true_command:

ret
check_gate_wire_diff endp

check_two_digits_zero_in_wire proc
cmp gate_number,11H
    jnz not_wire_command
    cmp second_column_leg,0
    jnz error_command
    jmp check_second_row
 error_command:jmp display_ll_error
 check_second_row:
    cmp second_row_leg,0
    jz  true_wire_command
    jmp display_ll_error
not_wire_command:
true_wire_command:
ret
check_two_digits_zero_in_wire endp

check_two_digits_zero_in_not proc
cmp gate_number,14h
    jnz not_not_command
    cmp second_column_leg,0
    jnz error_not_command
    jmp check_second_row_not
 error_not_command:jmp display_ll_error
 check_second_row_not:
    cmp second_row_leg,0
    jz  true_not_command
    jmp display_ll_error
not_not_command:
true_not_command:
ret
check_two_digits_zero_in_not endp

check_gate_number_is_true proc
 check_chatting_mode:
 cmp gate_number,2eh
 jnz check_remove_command
 jmp the_command_is_true
;check fisrt letter is a command or not
check_remove_command:
    cmp gate_number,32h
    jnz check_wire_command
    jmp the_command_is_true
check_wire_command:
    cmp gate_number,11H
    jnz check_and_command
    jmp the_command_is_true
check_and_command:
    cmp gate_number,1eh
    jnz check_nor_command
    jmp the_command_is_true
check_nor_command:
    cmp gate_number,13h
    jnz check_xor_command
    jmp the_command_is_true
check_xor_command:
    cmp gate_number,2dh
    jnz check_or_command
    jmp the_command_is_true
check_or_command:
    cmp gate_number,18h
    jnz check_xnor_command
    jmp the_command_is_true
check_xnor_command:
    cmp gate_number,31h
    jnz check_nand_command
    jmp the_command_is_true
check_nand_command:
    cmp gate_number,20H
    jnz check_level
    jmp the_command_is_true
check_level:
    cmp level_indication,1
    jnz check_not_command
    jmp display_ll_error
check_not_command:
    cmp gate_number,14h
    jz the_command_is_true
    jmp display_ll_error

the_command_is_true:

ret
check_gate_number_is_true endp

check_all_6_digits proc
cmp first_column_leg,9
    ja error_first_column
    jmp true_first_column
    error_first_column: jmp display_ll_error
true_first_column:


    cmp first_row_leg,9
    ja error_first_row
    jmp check_column0
    error_first_row: jmp display_ll_error
check_column0:
    cmp first_column_leg,0
    jz  true_first_row
    cmp first_row_leg,0
    jz error_first_row
    true_first_row:

    cmp second_column_leg,9
    ja error_second_column
    jmp true_second_column
    error_second_column: jmp display_ll_error
true_second_column:

    cmp second_row_leg,9
    ja error_second_row
    jmp check_column0_second
    error_second_row: jmp display_ll_error
check_column0_second:
    cmp second_column_leg,0
    jz  true_second_row
    cmp second_row_leg,0
    jz error_second_row
    true_second_row:

    cmp output_column,9
    ja error_output_column
    jmp check_not_column0
    error_output_column: jmp display_ll_error
check_not_column0:
    cmp output_column,0
    jz error_output_column
 true_output_column:


    cmp output_row,9
    ja error_output_row
    jmp check_column9_row
    error_output_row: jmp display_ll_error
check_column9_row:
    cmp output_column,9
    jz  true_output_row
    cmp output_row,0
    jz error_output_row
    true_output_row:
ret
check_all_6_digits endp

level_1_winner proc
mov i_won,0
mov opponnet_won,0
;for checking the winner for level 1
    mov bx,0
    mov cx,5            ;3dd l loops
check_my_nodes_ones:
    cmp arr_col9[bx],1
    jnz check_other_nodes
    mov ones_of_my_nodes,1
check_other_nodes:
    inc bx
    loop check_my_nodes_ones

    mov bx,5
    mov cx,5
    check_opponnet_nodes_ones:
    cmp arr_col9[bx],1
    jnz check_other_nodes2
    mov ones_of_opponnet_nodes,1
check_other_nodes2:
    inc bx
    loop check_opponnet_nodes_ones

    mov bx,0
    mov cx,5
check_my_nodes_zeros:
    cmp arr_col9[bx],0
    jnz check_other_nodes3
    mov zeros_of_my_nodes,1
check_other_nodes3:
    inc bx
    loop check_my_nodes_zeros

    mov bx,5
    mov cx,5
    check_opponnet_nodes_zeros:
    cmp arr_col9[bx],0
    jnz check_other_nodes4
    mov zeros_of_opponnet_nodes,1
check_other_nodes4:
    inc bx
    loop check_opponnet_nodes_zeros


check_if_i_won:
    cmp ones_of_my_nodes,1
    jnz check_if_opponnet_won

    cmp zeros_of_opponnet_nodes,1
    jnz check_if_opponnet_won

    mov i_won,1

    ;jmp new_round 

check_if_opponnet_won:
    cmp ones_of_opponnet_nodes,1
    jnz go_to_decide
    cmp zeros_of_my_nodes,1
    jnz go_to_decide
    mov opponnet_won,1
    
    ;jmp new_round


go_to_decide:
cmp i_won,1
jz continue_deciding
cmp opponnet_won,1
jz continue_deciding
jmp nothing_happen

continue_deciding:
mov al,opponnet_won
cmp i_won,al
jnz who_win?
jmp display_draw_message

who_win?:
cmp i_won,1
jnz so_opponnet_win
;set cursor
    mov ah,2      
    mov dx,0008h             
    mov bh,0
    int 10h

;display my named
    mov ah,9
    mov dx,offset upper_nodes_names
    int 21h

    ;set cursor
    mov ah,2      
    mov dx,0008h
    add dl,size_upper_name             
    mov bh,0
    int 10h
    ;display won message
    mov ah,9
    mov dx,offset i_win
    int 21h
    inc my_score
jmp new_round
so_opponnet_win:
    mov ah,2      
    mov dx,0008h             
    mov bh,0
    int 10h

;opponnet message won
    mov ah,9
    mov dx,offset lower_nodes_names
    int 21h

    ;set cursor
    mov ah,2      
    mov dx,0008h
    add dl,size_lower_name           
    mov bh,0
    int 10h

    ;display won message
    mov ah,9
    mov dx,offset i_win
    int 21h

    inc opponnet_score
    jmp new_round


display_draw_message:
    mov ah,9
    mov dx,offset draw_message
    int 21h
    jmp new_round

nothing_happen:
    jmp next_turn
ret
level_1_winner endp



score_screen proc
    mov ah,0          ;Change video mode (Text MODE)
    mov al,03h
    int 10h 
    ; clearing the screen
    mov ax,0600h  ;scroll screen
    mov bh,07
    mov cx,0
    mov dx,184Fh
    int 10h       ; clear screen

    ; set cursor
    mov ah,2      ; move cursor
    mov dx,061bh                              
    mov bh,0
    int 10h                     
    
    mov ah,9
    mov dx,offset upper_nodes_names
    int 21h

    
    ;set cursor
    mov ah,2      ; move cursor
    mov dx,061bh
    add dl,size_upper_name
    inc dl  
    mov bh,0
    int 10h
    
    mov ah,9
    mov dx,offset the_score
    int 21h

    mov ah,2          ;Display Char
    mov dl,my_score
    int 21h

    ; set cursor
    mov ah,2      ; move cursor
    mov dx,0c1bh
    mov bh,0
    int 10h

    mov ah,9
    mov dx,offset lower_nodes_names
    int 21h

     ; set cursor
    mov ah,2      ; move cursor
    mov dx,0c1bh
    add dl,size_lower_name
    inc dl
    mov bh,0
    int 10h

    mov ah,9
    mov dx,offset opponnet_score_message
    int 21h

    mov ah,2          ;Display Char
    mov dl,opponnet_score
    int 21h




; help_to_label_main:
 
  mov cx,4ch
  mov dx,4240h                 ;delay_5_seconds
  mov ah,86h
  int 15h
  jmp label_main_screen
ret
score_screen endp

intro_statment proc
mov cx,82d
    mov dx,0
    mov al,00
    mov si,offset letter_a
    call Draw_anything

    mov cx,89d
    mov dx,0
    mov al,00
    mov si,offset letter_a
    call Draw_anything
    
    mov cx,95d
    mov dx,0
    mov al,00
    mov si,offset letter_N
    call Draw_anything
    
    mov cx,101d
    mov dx,0d
    mov al,00
    mov si,offset letter_d
    call Draw_anything
    
    mov cx,108d
    mov dx,0d
    mov al,01
    mov si,offset letter_o
    call Draw_anything

    mov cx,115d
    mov dx,0d
    mov al,01
    mov si,offset letter_o
    call Draw_anything
    
    mov cx,121d
    mov dx,0d
    mov al,01
    mov si,offset letter_r
    call Draw_anything

    mov cx,128d
    mov dx,0d
    mov al,02
    mov si,offset letter_d
    call Draw_anything

    mov cx,135d
    mov dx,0d
    mov al,02
    mov si,offset letter_N
    call Draw_anything

    mov cx,141d
    mov dx,0d
    mov al,02
    mov si,offset letter_a
    call Draw_anything

    mov cx,147d
    mov dx,0d
    mov al,02
    mov si,offset letter_N
    call Draw_anything

    mov cx,153d
    mov dx,0d
    mov al,02
    mov si,offset letter_d
    call Draw_anything

    mov cx,160d
    mov dx,0d
    mov al,03
    mov si,offset letter_r
    call Draw_anything

    mov cx,167d
    mov dx,0d
    mov al,03
    mov si,offset letter_n
    call Draw_anything

    mov cx,173d
    mov dx,0d
    mov al,03
    mov si,offset letter_o
    call Draw_anything

    mov cx,179d
    mov dx,0d
    mov al,03
    mov si,offset letter_r
    call Draw_anything
    
    mov cx,186d
    mov dx,0d
    mov al,04
    mov si,offset letter_x
    call Draw_anything

    mov cx,193d
    mov dx,0d
    mov al,04
    mov si,offset letter_x
    call Draw_anything

    mov cx,199d
    mov dx,0d
    mov al,04
    mov si,offset letter_o
    call Draw_anything

    mov cx,205d
    mov dx,0d
    mov al,04
    mov si,offset letter_r
    call Draw_anything

     mov cx,212d
     mov dx,0d
    mov al,05
    mov si,offset letter_N
    call Draw_anything

     mov cx,219d
     mov dx,0d
    mov al,05
    mov si,offset letter_x
    call Draw_anything

     mov cx,225d
     mov dx,0d
    mov al,05
    mov si,offset letter_N
    call Draw_anything

     mov cx,231d
     mov dx,0d
    mov al,05
    mov si,offset letter_o
    call Draw_anything

     mov cx,237d
     mov dx,0d
    mov al,05
    mov si,offset letter_r
    call Draw_anything


ret
intro_statment endp

which_level proc
label_level_screen:
  mov ah,0          ;Change video mode (Text MODE)
   mov al,03h
   int 10h

   ;set cursor
    mov ah,2
    mov bh,0
    mov dx,081bh   
    int 10h

    mov ah,9
    mov dx,offset message_level1
    int 21h

    ;set cursor
    mov ah,2
    mov bh,0
    mov dx,101bh   
    int 10h

    mov ah,9
    mov dx,offset message_level2
    int 21h

    mov ah,0
    int 16h

    cmp al,31h
    jz true_level
    cmp al,32h
    jz true_level
    jmp label_level_screen

true_level:
sub al,30h
mov level_indication,al
    
ret
which_level endp

level_2_winner proc
;for checking the winner for level 2
    mov bx,0
    mov cx,5            ;3dd l loops
check_my_nodes_ones_2:
    cmp arr_col9[bx],1
    jnz check_opponnet_ones
check_other_nodes_2:
    inc bx
    loop check_my_nodes_ones_2


    mov bx,5
    mov cx,5
    check_opponnet_nodes_zeros_2:
    cmp arr_col9[bx],0
    jnz check_opponnet_ones
check_other_nodes4_2:
    inc bx
    loop check_opponnet_nodes_zeros_2

 ;set cursor
    mov ah,2      
    mov dx,0008h             
    mov bh,0
    int 10h
    ;display my named
    mov ah,9
    mov dx,offset upper_nodes_names
    int 21h

    ;set cursor
    mov ah,2      
    mov dx,0008h
    add dl,size_upper_name             
    mov bh,0
    int 10h
    ;display won message
    mov ah,9
    mov dx,offset i_win
    int 21h
    inc my_score

    jmp new_round 


check_opponnet_ones:
    mov bx,5
    mov cx,5
    check_opponnet_nodes_ones_2:
    cmp arr_col9[bx],1
    jnz no_one_won
check_other_nodes2_2:
    inc bx
    loop check_opponnet_nodes_ones_2


    mov bx,0
    mov cx,5
check_my_nodes_zeros_2:
    cmp arr_col9[bx],0
    jnz no_one_won
check_other_nodes3_2:
    inc bx
    loop check_my_nodes_zeros_2
    ;set cursor
    mov ah,2      
    mov dx,0008h             
    mov bh,0
    int 10h
    ;display my named
    mov ah,9
    mov dx,offset lower_nodes_names
    int 21h

    ;set cursor
    mov ah,2      
    mov dx,0008h
    add dl,size_lower_name             
    mov bh,0
    int 10h
    ;display won message
    mov ah,9
    mov dx,offset i_win
    int 21h
    inc opponnet_score
    jmp new_round
    
no_one_won:
    jmp next_turn
ret
level_2_winner endp

transmit_digit proc
    ;Check that Transmitter Holding Register is Empty
   repeat_digit:         mov dx , 3FDH		; Line Status Register
    AGAIN_digit:  
            In al , dx 			;Read Line Status
            AND al ,00100000b
            JZ AGAIN_digit

    ;If empty put the VALUE in Transmit data register
            mov dx ,3F8H		; Transmit data register
            mov al,my_command[bx]
            out dx,al
ret
transmit_digit endp
recieve_digit proc
 
    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al,dx 
ret
recieve_digit endp

in_line_chat_mode proc
call blacking_message_p1
call blacking_message_p2
			 ;set cursor
             mov ah,2
             mov dh,17h   ;row=2
             mov dl,0   ;col=0
             mov bh,0
             int 10h
             
             ;DisplayString(me) 
             mov ah,9
             mov dx,offset the_saved_username
             int 21h

             ;set cursor
             mov ah,2
             mov dh,17h   ;row=2
             mov dl,actual_size_of_username   ;col=0
             mov bh,0
             int 10h

             mov ah,2
             mov dl,":"
             int 21h       
             
			 mov cursor_me_row,17h
             mov al,actual_size_of_username
			 mov cursor_me_col,al
             inc cursor_me_col
			 
			 
			 
			
			
			;set cursor
             mov ah, 2
             mov dh,18h  ;row=15
             mov dl,0    ;col=0
             mov bh,0
             int 10h
             
             ;DisplayString(you) 
             mov ah,9
             mov dx,offset the_saved_opponnet_name
             int 21h   
             ;set cursor
             mov ah,2
             mov dh,18h   ;row=2
             mov dl,actual_size_opponnet_name   ;col=0
             mov bh,0
             int 10h

             
             mov ah,2
             mov dl,":"
             int 21h  
			 
			 mov cursor_you_row, 18h
             mov al,actual_size_opponnet_name
			 mov cursor_you_col, al
             inc cursor_you_col
             
            ;  ;set cursor
            ;  mov ah,2
            ;  mov dh,18h   ;row=2
            ;  mov dl,79  ;col=0
            ;  mov bh,0
            ;  int 10h

            ;  mov ah,2
            ;  mov dl,'a'
            ;  int 21h


			 
;------------------------------------------------------------------------------------------			 
			 
			;intializing com1
			
			;Set Divisor Latch Access Bit
			mov dx,3fbh ; Line Control Register
			mov al,10000000b ;Set Divisor Latch Access Bit
			out dx,al ;Out it
			
			;Set LSB byte of the Baud Rate Divisor Latch register.
			mov dx,3f8h
			mov al,0ch
			out dx,al
			
			;Set MSB byte of the Baud Rate Divisor Latch register.
			mov dx,3f9h
			mov al,00h
			out dx,al
			
			;Set port configuration
			mov dx,3fbh
			mov al,00011011b
			; •0:Access to Receiver buffer, Transmitter buffer
			; •0:Set Break disabled
			; •011:Even Parity
			; •0:One Stop Bit
			; •11:8bits
			out dx,al
			
			
			;checking if key is pressed and sending key to com2 
			
Again_inline:		mov ah,01		;check if key is pressed
			int 16h			
			jz Next1_inline			
			mov ah,0
			int 16h
				
			
			mov key, al

			
			
			;Check that Transmitter Holding Register is Empty
			
			 mov dx , 3FDH				 ; Line Status Register
AGAIN_T_inline:	 In al , dx 				 ;Read Line Status
			 AND al , 00100000b
			 JZ AGAIN_T_inline
			 
			 ;If empty put the VALUE in Transmit data register
			 mov dx , 3F8H 			; Transmit data register
			 mov al,key
			 out dx , al 
			 
			 ;set cursor
             mov ah, 2
             mov dh,17h
             mov dl,cursor_me_col 
             mov bh,0            
             int 10h
		
			;check if ascii is esc
			cmp key,1bh
			je exit1_inline
			
			
			
			cmp key,08			;backspace key pressed
			je backspace_me_inline
			
			mov ah,9 ;Display
			mov bh,0 ;Page 0
			mov al,key ;Letter 
			mov cx,1 ;1 times
			mov bl,0Fh 
			int 10h
			 
			inc cursor_me_col
			cmp cursor_me_col,40
			je  scroll_page_me_inline
			jmp Next_inline
			

Next1_inline: jmp Next_inline
		
	
			
backspace_me_inline:
            mov al,actual_size_of_username
            inc al
			cmp cursor_me_col,al
			je end_backspace_me1_inline
			dec cursor_me_col
			mov ah, 2
            mov dh,cursor_me_row
            mov dl,cursor_me_col
            mov bh,0
			int 10h
			mov ah,9
			mov al, ' '
			int 10h
			jmp Again1_inline
			
Again1_inline: 	jmp Again_inline	;out of range jump
exit1_inline:      jmp exit2_inline			;out of range jump



end_backspace_me1_inline: jmp end_backspace_me_inline		;out of range jump

scroll_page_me_inline:
            ; clearing the screen
; mov ax,0600h  ;scroll screen
; mov bh,07
; mov cl,actual_size_of_username
; inc cl
; mov ch,17h
; mov dx,174Fh
; int 10h       ; clear screen
call blacking_message_p1
mov al,actual_size_of_username
mov cursor_me_col,al
inc cursor_me_col
mov cursor_me_row,17h


			; mov ah, 2
            ; mov al,actual_size_of_username
            ; inc al
			; mov cursor_me_col,al
            ; mov dl,cursor_me_col   
			; mov dh, cursor_me_row
            ; mov bh,0
            ; int 10h
			; mov ah,6
			; mov al,1
			; mov bh,7 
			; mov ch,17h
			; mov cl,actual_size_of_username
            ; inc cl
			; mov dh,18h
			; mov dl,80
			; int 10h	
            ; mov al,actual
			; mov cursor_me_col,
            ; mov dl,cursor_me_col   
			; mov dh, cursor_me_row
            ; mov bh,0
            ; int 10h
			jmp Next_inline
			
			
			;get com 2 status
Next_inline:		mov dx , 3FDH			 ; Line Status Register
			in  al , dx 


			mov ah, al 
			And ah,01
			cmp ah,01
			jne Again1_inline	
			
			;If Ready read the VALUE in Receive data register
			 mov dx , 03F8H
			 in al , dx 
			 mov rec_value , al 		
			
			
			;check if ascii is esc
			cmp rec_value,1bh
			je exit2_inline
			
			
			
			cmp rec_value,08
			je backspace_you_inline
			
			
			;set cursor
            mov ah, 2
            mov dh,cursor_you_row
            mov dl,cursor_you_col  
            mov bh,0 
            int 10h
			 
			
			mov ah,9 ;Display
			mov bh,0 ;Page 0
			mov al, rec_value ;Letter 
			mov cx,1 ;1 times
			mov bl,0Fh 
			int 10h
			 
			inc cursor_you_col
			cmp cursor_you_col,40
			je scroll_page_you_inline
			jmp Next_inline
			

backspace_you_inline:

            mov al,actual_size_opponnet_name
            inc al
			cmp cursor_you_col,al
			je end_backspace_you_inline
			dec cursor_you_col
            mov ah, 2					;set cursor
            mov dh,cursor_you_row
            mov dl,cursor_you_col
            mov bh,0
			int 10h
			mov ah,9
			mov al, ' '
			int 10h
			jmp Next_inline

exit2_inline: 		jmp exit_in_line
			
			
			
end_backspace_you_inline:
			cmp cursor_you_row,18h
			je chat_done_you_inline
			dec cursor_you_row
			; mov ah,end_of_backspace_left_you
			mov cursor_you_col,80
			add cursor_you_col,2
			jmp Next_inline
			
chat_done_you_inline: 	jmp Next_inline


scroll_page_you_inline:
call blacking_message_p2
			mov al,actual_size_opponnet_name
mov cursor_you_col,al
inc cursor_you_col
mov cursor_you_row,18h

			jmp Next_inline

end_backspace_me_inline:

			cmp cursor_me_row,17h
			je inline_done_me
			dec cursor_me_row
			; mov ah,end_of_backspace_left_me
			mov cursor_me_col,80
			add cursor_me_col,2
			jmp Again_inline
			
inline_done_me:	jmp Again_inline				
	
				

exit_in_line:
jmp label_game_no_reset

ret
in_line_chat_mode endp
display_names proc
  ;set cursor
             mov ah,2
             mov dh,17h   ;row=2
             mov dl,0   ;col=0
             mov bh,0
             int 10h
             
             ;DisplayString(me) 
             mov ah,9
             mov dx,offset the_saved_username
             int 21h

             ;set cursor
             mov ah,2
             mov dh,17h   ;row=2
             mov dl,actual_size_of_username   ;col=0
             mov bh,0
             int 10h

             mov ah,2
             mov dl,":"
             int 21h       
             
			 mov cursor_me_row,17h
             mov al,actual_size_of_username
			 mov cursor_me_col,al
             inc cursor_me_col
			 
			 
			 
			
			
			;set cursor
             mov ah, 2
             mov dh,18h  ;row=15
             mov dl,0    ;col=0
             mov bh,0
             int 10h
             
             ;DisplayString(you) 
             mov ah,9
             mov dx,offset the_saved_opponnet_name
             int 21h   
             ;set cursor
             mov ah,2
             mov dh,18h   ;row=2
             mov dl,actual_size_opponnet_name   ;col=0
             mov bh,0
             int 10h

             
             mov ah,2
             mov dl,":"
             int 21h  
			 

ret
display_names endp

the_whole_game proc 
    mov ax,0a000h        ;drawing with arrays
    mov es,ax
    

    mov ah,0      ;Change video mode (Graphical MODE)
    mov al,13h    ;Max memory size 16KByte
    int 10h

    call draw_game  ;draw the whole game

    ;call randomize_values_first_col  ;kol mara b run l code b3ml randomize values
    call draw_first_col_nodes
    ;call in_line_chatting
    call intro_statment
    call display_names
    ; mov ah,2          ;Move Cursor
    ; mov dl,0
    ; mov dh,17h       ;X,Y Position
    ; mov bh,0
    ; int 10h           ;BIOS INT
    ; mov bx,offset the_saved_username
    ; call display_string
    ; mov ah,2          ;Move Cursor
    ; mov dl,0
    ; mov dh,18h       ;X,Y Position
    ; mov bh,0
    ; int 10h           ;BIOS INT
    ; mov bx,offset the_saved_opponnet_name
    ; call display_string
    start_play:
     mov bx,0
     mov si,0
    ; call get_first_letter    ;get the first letter and save it in gate_number and whitening the position which i display the command in it
    ; call get_first_column_leg   ;get fisrt column number and save it in first_column leg
    ; call get_first_row_leg      ;;get fisrt row number and save it in first_row leg
    ; call get_second_column_leg
    ; call get_second_row_leg
    ; call get_output_column
    ; call get_output_row
check_pressed_command:
    mov ah,1
    int 16h
    jz check_rec_command
    mov ah,0
    int 16h
    cmp ah,2eh
    jnz not_inline_chat
    jmp label_inline_request 
not_inline_chat:
    cmp ah,3eh
    jnz not_f4_exit
    jmp label_exit_request
not_f4_exit:
    mov dl,al
    sub al,30h
    cmp bx,0
    jnz ba2y_l_digits
    push ax
    push bx
    push dx
    call whitening_message
    mov ah,2          ;Move Cursor
    mov dl,0
    mov dh,0       ;X,Y Position
    mov bh,0
    int 10h           ;BIOS INT
    pop dx
    pop bx
    pop ax
    mov my_command[0],ah
    inc bx
    mov al,dl
    call display_char 
    jmp check_pressed_command
ba2y_l_digits:
    mov my_command[bx],al
    add al,30h
    call display_char
    inc bx
    cmp bx,7
    jz  nfz
    jmp check_pressed_command







    
    check_rec_command:
     mov dx , 3FDH		; Line Status Register  
            In al , dx 			;Read Line Status
            AND al ,00000001b
            jz check_pressed_command
    mov dx ,03F8H
    in al ,dx
    cmp al,'c'
    jnz not_rec_chat
    jmp label_inline_chat 
 not_rec_chat:
    cmp al,01
    jnz not_rec_exit
    jmp label_score_screen
not_rec_exit:
    mov bx,0
;Check that Data Ready
   repeat_command1:         mov dx , 3FDH		; Line Status Register
    CHK_command:	in al , dx 
            AND al ,1
            JZ CHK_command

    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al , dx 
            mov opponnet_command[bx], al
            cmp opponnet_command[bx],'$'
			jz exit_command
    
    inc bx
    jmp repeat_command1 
  exit_command:  
  jmp nfz_bta3k

    

    nfz_bta3k:
    mov al,opponnet_command[0]
    mov gate_number,al
    mov ah,0
    mov al,opponnet_command[1]
    mov first_column_leg,ax
    mov al,opponnet_command[2]
    mov first_row_leg,ax
    mov al,opponnet_command[3]
    mov second_column_leg,ax
    mov al,opponnet_command[4]
    mov second_row_leg,ax
    mov al,opponnet_command[5]
    mov output_column,ax
    mov al,opponnet_command[6]
    mov output_row,ax
    jmp do_command 

nfz:
     mov al,my_command[0]
    mov gate_number,al
    mov ah,0
    mov al,my_command[1]
    mov first_column_leg,ax
    mov al,my_command[2]
    mov first_row_leg,ax
    mov al,my_command[3]
    mov second_column_leg,ax
    mov al,my_command[4]
    mov second_row_leg,ax
    mov al,my_command[5]
    mov output_column,ax
    mov al,my_command[6]
    mov output_row,ax
    ;jmp do_command


    call check_gate_number_is_true      ;check that i have entered a true command in the game
    call check_all_6_digits             ;check that each digit is between the right range (0-9) or (1-9)
    call check_two_digits_zero_in_wire  ;check if the command is wire so the 2 digits in the middle is zeros
    call check_two_digits_zero_in_not   ;check if the command is not_gate so the 2 digits in the middle is zeros
    call check_gate_wire_diff           ;check that the gates is betweem two consecutive columns and wire may be diff=1 or 2
    call check_overwrite_in_output      ;each node is output for one gate only or one wire only


    mov dx ,3F8H		; Transmit data register
    mov al,5
    out dx,al
    mov cl,8
    mov ch,0
    mov bx,0
    ;Check that Transmitter Holding Register is Empty
   repeat_command:         mov dx , 3FDH		; Line Status Register
    AGAIN_command:  
            In al , dx 			;Read Line Status
            AND al ,00100000b
            JZ AGAIN_command

    ;If empty put the VALUE in Transmit data register
            mov dx ,3F8H		; Transmit data register
            mov al,my_command[bx]
            out dx,al
            inc bx
           ; inc temp_transmit
            dec cx
            jnz repeat_command

do_command:



    call removing_gates  ;if command is M so draw all gates in the position specified  and it remove the gate form its location in the saved_col?

    call output_position             ;lazm b3dha which gate to draw because it determine the position where i will draw in cx and dx
    call which_gate_to_draw         ; it takes the position and draw the gate where saved in gate_number

    call logic_game            ;make the operation required
    call save_the_inputs       ; it save all the inputs that i will enter except remove because it is not a gate or wire

label_game_no_reset:
    call re_calculate_logic     ;it re_calculate all the gates or wires i have entered to make sure that all logic is done
    call check_for_any_ones_to_colour            ;red
    call check_for_any_zeros_to_colour           ;green
    call check_for_any_undfined5_to_colour       ;black
    call clearing_buffer


    cmp level_indication,1
    jnz check_level2_winner
    call level_1_winner
    jmp next_turn
    check_level2_winner:
    call level_2_winner



    jmp next_turn
display_ll_error:
    call display_message_error


next_turn:
    jmp start_play

new_round:
    check_for_F4_button:
    call clearing_buffer
    mov  ah,0
    int  16h                            ;Get key pressed (do not wait for a key-AH:scancode,AL:ASCII)
    ;jz  check_for_F4_button
    cmp  ah,3eh
    jnz  check_for_F4_button
label_score_screen:
   call score_screen    
    ;jmp label_main_screen
label_exit_request:
    mov dx ,3F8H		; Transmit data register
    mov al,01
    out dx,al
    jmp label_score_screen
label_inline_request:
    mov dx ,3F8H		; Transmit data register
    mov al,'c'
    out dx,al
label_inline_chat:
call in_line_chat_mode


ret
the_whole_game endp

chatting_mode proc far		
					
		
			
			 ;Set text mode
             mov ax, 03h ;Text Mode. 80x25. 16 colors. 8 pages.
             int 10h
			 
			 ;set cursor
             mov ah,2
             mov dh,2   ;row=2
             mov dl,0   ;col=0
			 mov bh,0
             int 10h
             
             ;DisplayString(me) 
             mov ah,9
             mov dx,offset the_saved_username
             int 21h       
             
			 mov cursor_me_row, 3
             mov al,actual_size_of_username
			 mov cursor_me_col,al
			 
			 
			 
			 ;------------------Draw Line------------------------------
             ;set cursor
             mov ah, 2
             mov dh,13   ;row=13
             mov dl,0    ;col=0
			 mov bh,0
             int 10h
             
             mov ah,9    ;Display
             mov bh,0    ;Page 0
             mov al,'-'  ;ascii '-'
             mov cx,80   ;80 times
             mov bl,0Ah  ;Green (A) on black(0) background
             int 10h 
			
			
			;set cursor
             mov ah, 2
             mov dh,15  ;row=15
             mov dl,0    ;col=0
			 mov bh,0
             int 10h
             
             ;DisplayString(you) 
             mov ah,9
             mov dx,offset the_saved_opponnet_name
             int 21h       
             
			 
			 mov cursor_you_row, 16
             mov al,actual_size_opponnet_name
			 mov cursor_you_col,al
			 
;------------------------------------------------------------------------------------------			 
			 
			;intializing com1
			
			;Set Divisor Latch Access Bit
			mov dx,3fbh ; Line Control Register
			mov al,10000000b ;Set Divisor Latch Access Bit
			out dx,al ;Out it
			
			;Set LSB byte of the Baud Rate Divisor Latch register.
			mov dx,3f8h
			mov al,0ch
			out dx,al
			
			;Set MSB byte of the Baud Rate Divisor Latch register.
			mov dx,3f9h
			mov al,00h
			out dx,al
			
			;Set port configuration
			mov dx,3fbh
			mov al,00011011b
			; •0:Access to Receiver buffer, Transmitter buffer
			; •0:Set Break disabled
			; •011:Even Parity
			; •0:One Stop Bit
			; •11:8bits
			out dx,al
			
			
			;checking if key is pressed and sending key to com2 
			
Again:		mov ah,01		;check if key is pressed
			int 16h			
			jz Next1			
			mov ah,0
			int 16h
				
			
			mov key, al

			
			
			;Check that Transmitter Holding Register is Empty
			
			 mov dx , 3FDH				 ; Line Status Register
AGAIN_T:	 In al , dx 				 ;Read Line Status
			 AND al , 00100000b
			 JZ AGAIN_T
			 
			 ;If empty put the VALUE in Transmit data register
			 mov dx , 3F8H 			; Transmit data register
			 mov al,key
			 out dx , al 
			 
			 ;set cursor
             mov ah, 2
             mov dh,cursor_me_row
             mov dl,cursor_me_col
			 mov bh,0   
             int 10h
			
			;check if ascii is esc
			cmp key,1bh
			je exit1
			
			cmp key, 0dh		;enter key pressed
			je cursor_me_inc
			
			cmp key,08			;backspace key pressed
			je backspace_me
			
			mov ah,9 ;Display
			mov bh,0 ;Page 0
			mov al,key ;Letter 
			mov cx,1 ;1 times
			mov bl,0Fh 
			int 10h
			 
			inc cursor_me_col
			cmp cursor_me_col, 80
			je skip_me_inc
			jmp next
			

Next1: jmp Next
		
cursor_me_inc:
			; mov ah, cursor_me_col
			; mov end_of_backspace_left_me,ah
			
			cmp cursor_me_row,11
			jae scroll_page_me
			
			inc cursor_me_row
			mov cursor_me_col, 5
			mov ah, 2
            mov dh,cursor_me_row
            mov dl,cursor_me_col
			mov bh,0
			int 10h
			
			jmp next
			
backspace_me:
			cmp cursor_me_col,3
			je end_backspace_me1
			dec cursor_me_col
			mov ah, 2
            mov dh,cursor_me_row
            mov dl,cursor_me_col
			mov bh,0
			int 10h
			mov ah,9
			mov al, ' '
			int 10h
			jmp Again1
			
Again1: 	jmp Again	;out of range jump
exit1:      jmp exit2			;out of range jump


skip_me_inc:
			 
			 
			cmp cursor_me_row, 11
			jae scroll_page_me
			 
			inc cursor_me_row
			mov cursor_me_col, 4
			mov ah, 2
            mov dh,cursor_me_row
            mov dl,cursor_me_col
			mov bh,0
			int 10h
			 
			jmp Next

			


end_backspace_me1: jmp end_backspace_me		;out of range jump

scroll_page_me:
			mov ah, 2
			mov cursor_me_col,4
            mov dl,cursor_me_col   
			mov dh, cursor_me_row
            int 10h
			mov ah,6
			mov al,1
			mov bh,7 
			mov ch,3
			mov cl,4
			mov dh,11
			mov dl,80
			int 10h	
			mov cursor_me_col,4
            mov dl,cursor_me_col   
			mov dh, cursor_me_row
            int 10h
			jmp Next
			
			
			;get com 2 status
Next:		mov dx , 3FDH			 ; Line Status Register
			in  al , dx 


			mov ah, al 
			And ah,01
			cmp ah,01
			jne Again1	
			
			;If Ready read the VALUE in Receive data register
			 mov dx , 03F8H
			 in al , dx 
			 mov rec_value , al 		
			
			
			;check if ascii is esc
			cmp rec_value,1bh
			je exit2
			
			
			cmp rec_value, 0dh
			je cursor_you_inc
			
			cmp rec_value,08
			je backspace_you
			
			
			;set cursor
            mov ah, 2
            mov dh,cursor_you_row
            mov dl,cursor_you_col  
			mov bh,0 
            int 10h
			 
			
			mov ah,9 ;Display
			mov bh,0 ;Page 0
			mov al, rec_value ;Letter 
			mov cx,1 ;1 times
			mov bl,0Fh 
			int 10h
			 
			inc cursor_you_col
			cmp cursor_you_col, 80
			je skip_you_inc
			jmp Next
			
cursor_you_inc:

 			; mov ah, cursor_you_col
			; mov end_of_backspace_left_you,ah
			
			
			cmp cursor_you_row,24
			jae scroll_page_you
			
			inc cursor_you_row
			mov cursor_you_col, 5
			mov ah, 2
            mov dh,cursor_you_row
            mov dl,cursor_you_col
			mov bh,0
			int 10h
			jmp Next

backspace_you:

			cmp cursor_you_col,3
			je end_backspace_you
			dec cursor_you_col
            mov ah, 2					;set cursor
            mov dh,cursor_you_row
            mov dl,cursor_you_col
			mov bh,0
			int 10h
			mov ah,9
			mov al, ' '
			int 10h
			jmp Next

exit2: 		jmp exit3
			
skip_you_inc:	
		
			cmp cursor_you_row, 24
			jae scroll_page_you
			
			inc cursor_you_row
			mov cursor_you_col, 4
			mov ah, 2					;set cursor
            mov dh,cursor_you_row
            mov dl,cursor_you_col
			mov bh,0
			int 10h
			jmp Next
			

			
end_backspace_you:
			cmp cursor_you_row,16
			je chat_done_you
			dec cursor_you_row
			; mov ah,end_of_backspace_left_you
			mov cursor_you_col,80
			add cursor_you_col,2
			jmp Next
			
chat_done_you: 	jmp Next


scroll_page_you:
			mov ah, 2
			mov cursor_you_col,4
            mov dl,cursor_you_col  
			mov dh, cursor_you_row
			mov bh,0
            int 10h
			mov ah,6
			mov al,1
			mov bh,7 
			mov ch,16
			mov cl,4
			mov dh,24
			mov dl,80
			int 10h	
			mov ah, 2
			mov cursor_you_col,4
            mov dl,cursor_you_col  
			mov dh, cursor_you_row
            int 10h
			jmp Next

end_backspace_me:

			cmp cursor_me_row,3
			je chat_done_me
			dec cursor_me_row
			; mov ah,end_of_backspace_left_me
			mov cursor_me_col,80
			add cursor_me_col,2
			jmp Again
			
chat_done_me:	jmp Again				
				
				

exit3:		

    
exit_chat:
        jmp label_main_screen

ret
chatting_mode endp

transmit_char proc
mov dx , 3FDH		; Line Status Register
    AGAIN_trans2:  
            In al , dx 			;Read Line Status
            AND al ,00100000b
            JZ AGAIN_trans2

    ;If empty put the VALUE in Transmit data register
            mov dx ,3F8H		; Transmit data register
            ;mov al,3bh
            mov al,ah
            out dx,al
ret
transmit_char endp

recieve_char proc

      mov dx , 3FDH		; Line Status Register
     hold:
         	in al , dx 
            AND al,1
            JZ hold

    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al,dx 
            cmp al,3bh
            jnz check_game_invite
            jmp go_to_chat
check_game_invite:
            cmp al,3ch
            jnz hold
            call rec_game_notfi
   right_key_press:
   mov ah,1
   int 16h
   jz if_acceptance_come
   mov ah,0
   int 16h
   cmp ah,3ch
   jnz right_key_press
   jmp i_accept_game

if_acceptance_come:
mov dx , 3FDH		; Line Status Register
     if_accept:
         	in al , dx 
            AND al,1
            JZ right_key_press
            mov dx , 03F8H
            in al,dx 
            cmp al,3bh
            jnz if_acceptance_come
            jmp go_to_chat

i_accept_game:
            call transmit_char
            call recieve_values_random
            jmp label_which_level_game


go_to_chat:
ret
recieve_char endp

define_level_screen proc

mov ah,0          ;Change video mode (Text MODE)
mov al,03h
int 10h
; clearing the screen
mov ax,0600h  ;scroll screen
mov bh,07
mov cx,0
mov dx,184Fh
int 10h       ; clear screen

; set cursor
mov ah,2      ; move cursor
mov dx,0c1eh
mov bh,0
int 10h

mov ah,9
mov dx,offset define_level
int 21h

mov ah,2
mov dl,level_indication
add dl,30h
int 21h

  mov cx,4ch
  mov dx,4240h                 ;delay_5_seconds
  mov ah,86h
  int 15h

ret
define_level_screen endp

transmit_level proc
mov dx , 3FDH		; Line Status Register
    AGAIN_trans3:  
            In al , dx 			;Read Line Status
            AND al ,00100000b
            JZ AGAIN_trans3

    ;If empty put the VALUE in Transmit data register
            mov dx ,3F8H		; Transmit data register
            ;mov al,3bh
            mov al,level_indication
            out dx,al
ret
transmit_level endp

recieve_level proc
mov dx , 3FDH		; Line Status Register
     hold1:
         	in al , dx 
            AND al,1
            JZ hold1

    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al,dx
            mov level_indication,al 
ret
recieve_level endp

static_game proc far 
mov ax,0a000h        ;drawing with arrays
    mov es,ax
    

    mov ah,0      ;Change video mode (Graphical MODE)
    mov al,13h    ;Max memory size 16KByte
    int 10h

    call draw_game  ;draw the whole game
    ;call randomize_values_first_col  ;kol mara b run l code b3ml randomize values
    ;call in_line_chatting
    call intro_statment
ret
static_game endp

transmit_values_random proc
    mov cl,10
    inc cl
    mov ch,0
    mov bx,0
    ;Check that Transmitter Holding Register is Empty
   repeat_values:         mov dx , 3FDH		; Line Status Register
    AGAIN_values:  
            In al , dx 			;Read Line Status
            AND al ,00100000b
            JZ AGAIN_values

    ;If empty put the VALUE in Transmit data register
            mov dx ,3F8H		; Transmit data register
            mov al,arr_col0[bx]
            out dx,al
            inc bx
            ; mov ah,2
            ; add al,30h
            ; mov dl,al
            ; int 21h
           ; inc temp_transmit
            dec cx
            jnz repeat_values

ret
transmit_values_random endp

recieve_values_random proc
mov bx,0
;Check that Data Ready
   recieve_values:         mov dx , 3FDH		; Line Status Register
    CHK_values:	in al , dx 
            AND al ,1
            JZ CHK_values

    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al , dx 
            cmp al,'$'
            jz exit_values
            mov arr_col0[bx], al
            ; mov ah,2
            ; add al,30h
            ; mov dl,al
            ; int 21h
            
    inc bx
    jmp recieve_values 

exit_values:


ret
recieve_values_random endp

you_sent_game_notfi proc
; set cursor
mov ah,2      ; move cursor
mov dx,1700h
mov bh,0
int 10h

 mov ah,9
 mov dx,offset send_notification_game
 int 21h

 mov ah,9
 mov dx,offset the_saved_opponnet_name
 int 21h
ret
you_sent_game_notfi endp

rec_game_notfi proc
; set cursor
            mov ah,2      ; move cursor
            mov dx,1800h
            ;mov bh,0
            int 10h
            mov bx,offset the_saved_opponnet_name
            call display_string
            ; set cursor
            mov ah,2      ; move cursor
            mov dh,18h
            mov dl,actual_size_opponnet_name
            ;mov bh,0
            int 10h
            mov bx,offset receieved_notification_game
            call display_string
ret
rec_game_notfi endp

recieve_game_accept proc
 mov dx , 3FDH		; Line Status Register
     hold2:
         	in al , dx 
            AND al,1
            JZ hold2

    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al,dx 
            cmp al,3ch
            jnz check_chat_invite
            jmp go_to_game
check_chat_invite:
            cmp al,3bh
            jnz hold2
           ; set cursor
            mov ah,2      ; move cursor
            mov dx,1800h
            ;mov bh,0
            int 10h
            mov bx,offset the_saved_opponnet_name
            call display_string
            ; set cursor
            mov ah,2      ; move cursor
            mov dh,18h
            mov dl,actual_size_opponnet_name
            ;mov bh,0
            int 10h
            mov bx,offset receieved_notification_chat
            call display_string
   right_key_press2:
   mov ah,1
   int 16h
   jz if_acceptance_come2
   mov ah,0
   int 16h
   cmp ah,3bh
   jnz right_key_press2
   jmp i_accept_chat

if_acceptance_come2:
mov dx , 3FDH		; Line Status Register
     if_accept2:
         	in al , dx 
            AND al,1
            JZ right_key_press2
            mov dx , 03F8H
            in al,dx 
            cmp al,3ch
            jnz if_acceptance_come2
            jmp go_to_game

i_accept_chat:
            call transmit_char
            jmp label_chat_mode


go_to_game:
ret
recieve_game_accept endp

send_notfi_chat proc
mov ah,2      ; move cursor
mov dx,1700h
mov bh,0
int 10h

 mov ah,9
 mov dx,offset send_notification_chat
 int 21h

 mov ah,9
 mov dx,offset the_saved_opponnet_name
 int 21h
ret
send_notfi_chat endp


main_screen proc ;far
mov ah,0          ;Change video mode (Text MODE)
mov al,03h
int 10h
; clearing the screen
mov ax,0600h  ;scroll screen
mov bh,07
mov cx,0
mov dx,184Fh
int 10h       ; clear screen

; set cursor
mov ah,2      ; move cursor
mov dx,061bh
mov bh,0
int 10h

; start screen
lea bx,string_chat
call display_string

; set cursor
mov ah,2      ; move cursor
mov dx,0C1bh
mov bh,0
int 10h
lea bx,string_game
call display_string

; set cursor
mov ah,2      ; move cursor
mov dx,121bh
mov bh,0
int 10h
lea bx,string_exit
call display_string



get_key_pressed:
mov ah,1
int 16h
jz check_recieved_invitation
mov ah,0
int 16h
cmp ah,3bh
jnz check_f2
jmp f1_pressed
check_f2:
cmp ah,3ch
jnz check_esc
jmp f2_pressed
check_esc:
cmp ah,01h
jnz get_key_pressed
f1_pressed:
f2_pressed:
jmp transmit_notification

check_recieved_invitation:
repeat_rec1:         mov dx , 3FDH		; Line Status Register
         	in al , dx 
            AND al,1
            JZ get_key_pressed
    ;If Ready read the VALUE in Receive data register
            mov dx , 03F8H
            in al , dx 

           ; mov recieved_invitaion, al
            cmp al,3bh  ;f1 chat 
            jnz check_game
            ; set cursor
            mov ah,2      ; move cursor
            mov dx,1800h
            ;mov bh,0
            int 10h
            mov bx,offset the_saved_opponnet_name
            call display_string
            ; set cursor
            mov ah,2      ; move cursor
            mov dh,18h
            mov dl,actual_size_opponnet_name
            ;mov bh,0
            int 10h
            mov bx,offset receieved_notification_chat
            call display_string
    wait_to_f1:
            mov ah,0
            int 16h
            cmp ah,3bh
            jnz check_if_f2?
            mov ah,3bh
            jmp goto_chat
 check_if_f2?:
            cmp ah,3ch 
            jnz wait_to_f1
            call you_sent_game_notfi
            mov ah,3ch
                                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            jmp right_key
                       
 right_key:
            call transmit_char
 pressed_something:
            mov ah,1
            int 16h
            jz if_accept_game
            mov ah,0
            int 16h
            cmp ah,3bh
            jnz if_accept_game
            call transmit_char
            jmp goto_chat


if_accept_game:mov dx , 3FDH		; Line Status Register
     if_accept_come:
         	in al , dx 
            AND al,1
            JZ pressed_something
            mov dx , 03F8H
            in al,dx 
            cmp al,3ch
            jnz if_accept_come
            jmp initiated_game
            
goto_chat:
          call transmit_char
         jmp label_chat_mode
    
check_game:
            cmp al,3ch   ;f2 game
            jnz  check_esc_recieved
            ; set cursor
            mov ah,2      ; move cursor
            mov dx,1800h
            ;mov bh,0
            int 10h
            mov bx,offset the_saved_opponnet_name
            call display_string
            ; set cursor
            mov ah,2      ; move cursor
            mov dh,18h
            mov dl,actual_size_opponnet_name
            ;mov bh,0
            int 10h
            mov bx,offset receieved_notification_game
            call display_string
    wait_to_f2:
            mov ah,0
            int 16h
            cmp ah,3ch
            jnz check_if_f1
            jmp goto_game
check_if_f1:        
            cmp ah,3bh
            jnz wait_to_f2
            ; set cursor
call send_notfi_chat

 mov ah,3bh
 call transmit_char
 pressed_something_accept:
            mov ah,1
            int 16h
            jz if_accept_chat
            mov ah,0
            int 16h
            cmp ah,3ch
            jnz if_accept_chat
            jmp goto_game


if_accept_chat:mov dx , 3FDH		; Line Status Register
     if_accept_come2:
         	in al , dx 
            AND al,1
            JZ pressed_something_accept
            mov dx , 03F8H
            in al,dx 
            cmp al,3bh
            jnz if_accept_come2
            jmp label_chat_mode
            



goto_game:
            call transmit_char
            call recieve_values_random
            jmp label_which_level_game
check_esc_recieved:
            jmp end_program
            
error_reply:


transmit_notification:
         mov dx , 3FDH		; Line Status Register
    AGAIN_trans1:  
            In al , dx 			;Read Line Status
            AND al ,00100000b
            JZ AGAIN_trans1

    ;If empty put the VALUE in Transmit data register
            mov dx ,3F8H		; Transmit data register
            ;mov al,3bh
            mov al,ah
            out dx,al


;jz get_key_pressed

cmp ah,3bh  ;f1 chat 
jz  chat
cmp ah,3ch   ;f2 game
jz  game 
cmp ah,01h  ;exit
jz  help_close_program 

; clearing the buffer
call clearing_buffer
jmp get_key_pressed

 chat:
 ; set cursor
mov ah,2      ; move cursor
mov dx,1700h
;mov bh,0
int 10h

 mov ah,9
 mov dx,offset send_notification_chat
 int 21h

 mov ah,9
 mov dx,offset the_saved_opponnet_name
 int 21h

call recieve_char


label_chat_mode:
call chatting_mode
 
; clearing the buffer
call clearing_buffer
jmp end_program  
help_close_program: jmp close_program      
       
 game:
 ; set cursor
mov ah,2      ; move cursor
mov dx,1700h
mov bh,0
int 10h

 mov ah,9
 mov dx,offset send_notification_game
 int 21h
 
 mov ah,9
 mov dx,offset the_saved_opponnet_name
 int 21h

call recieve_game_accept
initiated_game:
mov bx,0
mov ch,0
mov cl,actual_size_of_username
get_the_upper:
mov al,the_saved_username[bx]
 mov upper_nodes_names[bx],al
 inc bx
 dec cx
 jnz get_the_upper

 mov al,actual_size_of_username
 mov size_upper_name,al

 mov bx,0
 mov ch,0
mov cl,actual_size_opponnet_name
get_the_lower:
mov al,the_saved_opponnet_name[bx]
 mov lower_nodes_names[bx],al
 inc bx
 dec cx
 jnz get_the_lower

 mov al,actual_size_opponnet_name
 mov size_lower_name,al
 

 
 call randomize_values_first_col
 call transmit_values_random
 call which_level
 call transmit_level
 jmp label_game_mode

 ;call clearing_buffer

 label_which_level_game:
 mov bx,0
 mov ch,0
mov cl,actual_size_of_username
get_the_lower2:
mov al,the_saved_username[bx]
 mov lower_nodes_names[bx],al
 inc bx
 dec cx
 jnz get_the_lower2

 mov al,actual_size_of_username
 mov size_lower_name,al

 mov bx,0
 mov ch,0
mov cl,actual_size_opponnet_name
get_the_upper2:
mov al,the_saved_opponnet_name[bx]
 mov upper_nodes_names[bx],al
 inc bx
 dec cx
 jnz get_the_upper2

 mov al,actual_size_opponnet_name
 mov size_upper_name,al

 call static_game
 call recieve_level
 call define_level_screen
 label_game_mode:
 call reset_data_variables
 call the_whole_game
 
  call clearing_buffer
  jmp end_program  
  
 close_program:
 call clearing_buffer
 
; closing the program
end_program:
ret
main_screen endp

get_username_inline proc
mov al,the_saved_username[bx]
  cmp al,61h
  jnz check_letter_b
  mov si,offset letter_a
  jmp i_got_the_letter

check_letter_b:
  mov al,the_saved_username[bx]
  cmp al,62h
  jnz check_letter_c
  mov si,offset letter_b
  jmp i_got_the_letter
check_letter_c:
   mov al,the_saved_username[bx]
  cmp al,63h
  jnz check_letter_d
  mov si,offset letter_c
  jmp i_got_the_letter

check_letter_d:
  mov al,the_saved_username[bx]
  cmp al,64h
  jnz check_letter_e
  mov si,offset letter_d
  jmp i_got_the_letter

  check_letter_e:
  mov al,the_saved_username[bx]
  cmp al,65h
  jnz check_letter_f
  mov si,offset letter_e
  jmp i_got_the_letter

  check_letter_f:
  mov al,the_saved_username[bx]
  cmp al,66h
  jnz check_letter_g
  mov si,offset letter_f
  jmp i_got_the_letter

  check_letter_g:
  mov al,the_saved_username[bx]
  cmp al,67h
  jnz check_letter_h
  mov si,offset letter_g
  jmp i_got_the_letter

check_letter_h:

  mov al,the_saved_username[bx]
  cmp al,68h
  jnz check_letter_i
  mov si,offset letter_h
  jmp i_got_the_letter

  check_letter_i:
  mov al,the_saved_username[bx]
  cmp al,69h
  jnz check_letter_j
  mov si,offset letter_I
  jmp i_got_the_letter

  check_letter_j:
  mov al,the_saved_username[bx]
  cmp al,6ah
  jnz check_letter_k
  mov si,offset letter_j
  jmp i_got_the_letter

check_letter_k:
  mov al,the_saved_username[bx]
  cmp al,6bh
  jnz check_letter_l
  mov si,offset letter_K
  jmp i_got_the_letter

  check_letter_l:
  mov al,the_saved_username[bx]
  cmp al,6ch
  jnz check_letter_m
  mov si,offset letter_L
  jmp i_got_the_letter

  check_letter_m:
  mov al,the_saved_username[bx]
  cmp al,6dh
  jnz check_letter_n
  mov si,offset letter_M
  jmp i_got_the_letter

  check_letter_n:
  mov al,the_saved_username[bx]
  cmp al,6eh
  jnz check_letter_o
  mov si,offset letter_N
  jmp i_got_the_letter

  check_letter_o:
  mov al,the_saved_username[bx]
  cmp al,6fh
  jnz check_letter_p
  mov si,offset letter_o
  jmp i_got_the_letter

  check_letter_p:
  mov al,the_saved_username[bx]
  cmp al,70h
  jnz check_letter_q
  mov si,offset letter_p
  jmp i_got_the_letter

check_letter_q:

  mov al,the_saved_username[bx]
  cmp al,71h
  jnz check_letter_r
  mov si,offset letter_q
  jmp i_got_the_letter

check_letter_r:

  mov al,the_saved_username[bx]
  cmp al,72h
  jnz check_letter_s
  mov si,offset letter_r
  jmp i_got_the_letter
   
   check_letter_s:
  mov al,the_saved_username[bx]
  cmp al,73h
  jnz check_letter_t
  mov si,offset letter_s
  jmp i_got_the_letter

check_letter_t:
  mov al,the_saved_username[bx]
  cmp al,74h
  jnz check_letter_u
  mov si,offset letter_t
  jmp i_got_the_letter

check_letter_u:

  mov al,the_saved_username[bx]
  cmp al,75h
  jnz check_letter_v
  mov si,offset letter_u
  jmp i_got_the_letter

check_letter_v:
  mov al,the_saved_username[bx]
  cmp al,76h
  jnz check_letter_w
  mov si,offset letter_v
  jmp i_got_the_letter

check_letter_w:

  mov al,the_saved_username[bx]
  cmp al,77h
  jnz check_letter_x
  mov si,offset letter_w
  jmp i_got_the_letter

check_letter_x:
  mov al,the_saved_username[bx]
  cmp al,78h
  jnz check_letter_y
  mov si,offset letter_x
  jmp i_got_the_letter

check_letter_y:
  mov al,the_saved_username[bx]
  cmp al,79h
  jnz check_letter_z
  mov si,offset letter_y
  jmp i_got_the_letter

check_letter_z:
 mov al,the_saved_username[bx]
  cmp al,7ah
  jnz check_ba2y_letters
  mov si,offset letter_z
  jmp i_got_the_letter


  jmp check_ba2y_letters
  i_got_the_letter:
   mov al,02
   push cx
   mov cx,di
   add di,6
   call Draw_anything
   pop cx


check_ba2y_letters:

ret
get_username_inline endp


main proc far
    mov ax,@data
    mov ds,ax
    mov ax,0h
   ;call chatting_mode
   call defining_screen
label_main_screen:
   call main_screen
   
     
    ;closing program
    mov ah,4ch
    int 21h
    ;mov ah,0ch
    ;int 20h 
    hlt
main endp
end main
